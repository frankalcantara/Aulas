<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="author" content="Frank Coelho de Alcantara -2020" />
  <title>Gramáticas</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta
    name="apple-mobile-web-app-status-bar-style"
    content="black-translucent" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" />
  <link rel="stylesheet" href="../../rev/reset.css" />
  <link rel="stylesheet" href="../../rev/reveal.css" />
  <link rel="stylesheet" href="../../rev/interpret.css" />
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section id="title-slide" class="nivel1">
        <h1 class="title">Gramáticas</h1>
        <p style="text-align: right !important">
          Frank Coelho de Alcantara - 2021 &nbsp;&nbsp;&nbsp;
        </p>
      </section>
      <section>
        <section class="nivel1">
          <h2>Regex?</h2>
            <p class="fragment fade-up">Infelizmente Expressões Regulares apresentam algumas limitações para a definição de uma linguagem de programação.</p>
            <p class="fragment fade-up">As Regex são excelentes, ainda que lentas, para identificação de lexemas.</p>
            <p class="fragment fade-up">Muito difícil fazer uma expressão regular para garantir os pares de parênteses.</p>
            <p class="fragment fade-up">Muito difícil fazer uma expressão regular para funções e objetos garantindo os escopos.</p>
        </section>
      </section>
      <section>
        <section class="nivel1">
          <h2>Gramáticas</h2>
          <p class="fragment fade-up">
            A <b>linguagem das linguagens</b>: Uma gramática é uma lista de regras
            que determina como podem ser criadas e utilizadas todas as <i>strings</i> 
            de uma linguagem;
          </p>
          <p class="fragment fade-up">
            <a href="https://en.wikipedia.org/wiki/Noam_Chomsky" target="_blank" rel="noopener noreferrer">Noam Chomsky</a> 
            é um dos pesquisadores mais importantes nesta área.</p>
          <p class="fragment fade-up">
            A nós, nesta disciplina, interessam apenas as gramáticas livres de contexto e as regulares. As gramáticas 
            livres de contextos são um superconjunto das gramáticas regulares.
          </p>
        </section>
        <section class="nivel1">
          <h2>Linguagens e Chomsky</h2>
          <table style="font-size: 80% !important">
            <tbody>
              <tr>
                <th><i>Linguagem</i></th>
                <th><i>Gramática</i></th>
                <th><i>Identificador</i></th>
              </tr>
              <tr>
                <td>Recursivamente Enumeráreis</td>
                <td>Gramáticas Irrestritas</td>
                <td>Máquina de Touring</td>
              </tr>
              <tr>
                <td>Linguagens sensíveis ao contexto</td>
                <td>Gramáticas sensíveis ao contexto</td>
                <td>Maq. Turing com fita limitada</td>
              </tr>
              <tr>
                <td>Linguagens livres de contexto</td>
                <td>Gramáticas livres de contexto</td>
                <td>Autômato com pilha</td>
              </tr>
              <tr>
                <td>Linguagens Regulares</td>
                <td>Gramáticas regulares</td>
                <td>Autômato finito</td>
              </tr>
            </tbody>
          </table>
        </section>
        <section class="nivel1">
          <h2>Gramáticas - definição</h2>
          <p class="fragment fade-up">Uma Gramática Formal: 4-tupla: $$𝑮 := \{𝑵, \Sigma, 𝑷, 𝑺\}$$</p>
          <ul>
            <li class="fragment fade-up">$S\rightarrow \text{símbolo inicial}$</li>
            <li class="fragment fade-up">$\Sigma \rightarrow \text{símbolos terminais}$</li>
            <li class="fragment fade-up">$P \rightarrow \text{regras de produção}$</li>
            <li class="fragment fade-up">$N \rightarrow \text{símbolos não terminais}$</li>
          </ul>
        </section>
        <section class="nivel1">
          <h2>Livres de Contexto</h2>
          <p class="fragment fade-up">
            Uma gramática livre de contexto é uma álgebra que descreve um conjunto de strings 
            por meio da definição da estrutura das strings que formarão a linguagem.</p>
          <p class="fragment fade-up">Esta definição é recursiva, indicando que cada regra
          produção pode, ou não, ser utilizada para definir novas regras de produção</p>
          <p class="fragment fade-up">$$ STMT \rightarrow \space if \space EXPRESS \space STMT \space else \space STMT$$</p>
        </section>
      </section>
      <section>
        <section class="nivel1">
          <h2>Regras de Produção</h2>
          <p class="fragment fade-up">
            Os símbolos que aparecem à esquerda da seta, são não terminais e
            representados por letras latinas maiúsculas $(𝐴, 𝐵, 𝑆, …)$.
          </p>
          <p class="fragment fade-up">
            O símbolo inicial é o que aparece do lado esquerdo da primeira
            regra, no nosso caso, na maior parte das vezes: $𝑆$.
          </p>
          <p class="fragment fade-up">Pode ser qualquer símbolo, usaremos o $𝑆$ por convenção.</p>
        </section>
        <section class="nivel1">
          <h2>Exemplo 1</h2>
          <ol>
            <li>$𝑆 \rightarrow 𝐴𝐵$</li>
            <li>$𝑆 \rightarrow 𝐴𝑆𝐵$</li>
            <li>$𝐴 \rightarrow a$</li>
            <li>$𝐵 \rightarrow b$</li>
          </ol>
          <p class="fragment fade-up">Vamos produzir a string:“aabb”</p>
        </section>
        <section class="nivel1">
          <h2>Exemplo 1 - Derivando $aabb$</h2>
          <ol style="float: right; width: 15%; font-size: 58%; margin-right: 1%;">
            <li>$𝑆 \rightarrow 𝐴𝐵$</li>
            <li>$𝑆 \rightarrow 𝐴𝑆𝐵$</li>
            <li>$𝐴 \rightarrow a$</li>
            <li>$𝐵 \rightarrow b$</li>
          </ol>
          <small style="float: left; width: 68%; margin-left: 2%; font-size: 80%!important;"> 
            <p class="fragment fade-up">
            Temos $S \rightarrow \emptyset$ e aplicamos 2 $𝑺 \rightarrow 𝑨𝑺𝑩$
          </p>
          <p class="fragment fade-up">
            Temos de $S \rightarrow ASB$ e aplicamos 3 $A \rightarrow a$
          </p>
          <p class="fragment fade-up">
            Temos de $S \rightarrow aSB$ e aplicamos 4 $B \rightarrow b$
          </p>
          <p class="fragment fade-up">
            Temos de $S \rightarrow aSb$ e aplicamos 1 $𝑺 \rightarrow AB$
          </p>
          <p class="fragment fade-up">
            Temos de $S \rightarrow aABb$ e aplicamos 3 $A \rightarrow a$
          </p>
          <p class="fragment fade-up">
            Temos de $S \rightarrow aaBb$ e aplicamos 4 $B \rightarrow b$
          </p>
          <p class="fragment fade-up">Conseguimos: $S \rightarrow aabb$</p>
          </small>
        </section>
        <section class="nivel1">
          <h2>Exemplo 2</h2>
          <ol style="font-size: 80% !important;">
            <li>$𝑆TMT \space \rightarrow IFSTMT \space | \space outracoisa$</li>
            <li>$IFSTMT \rightarrow if \space (EXP) \space STMT \space ELSESTMT$</li>
            <li>$ELSESTMT \rightarrow else \space STMT \space | \space \varepsilon$</li>
            <li>$EXP \rightarrow 0|1$</li>
          </ol>
          <p class="fragment fade-up">Que pode gerar / identificar: </p>
          <p class="fragment fade-up"><i>outracoisa</i> </p>
          <p class="fragment fade-up"><i>if (0) outracoisa</i> </p>
          <p class="fragment fade-up"><i>if (1) outracoisa else if (0) outracoisa else outracoisa</i> </p>
        </section>
        <section class="nivel1">
          <h2>Exercício Formativo 1</h2>
          <p>Considere a gramática definida por:</p>
          <ol>
            <li>$𝑺 \rightarrow 𝑨𝑩$</li>
            <li>$𝑨 \rightarrow \varepsilon | 𝒂𝑨$</li>
            <li>$𝑩 \rightarrow \varepsilon | 𝒃𝑩$</li>
          </ol>
          <p>Encontre uma sequência de substituições para encontrar: $aab$</p>
        </section>
        <section class="nivel1">
          <h2>Gramáticas Regulares</h2>
          <p class="fragment fade-up">Duas classes de regras de produção.</p>
          <p class="fragment fade-up">
            Lineares à Direita: as regras de produção obedecem: $$𝑨
            \rightarrow 𝒘𝑩 \vee 𝑨\rightarrow 𝒘 (𝒘 \in \Sigma^*)$$
          </p>
          <p class="fragment fade-up">
            Lineares à esquerda: as regras de produção obedecem: $$𝑨
            \rightarrow 𝑩𝒘 \vee 𝑨 \rightarrow 𝒘 (𝒘 \in \Sigma^*)$$
          </p>
        </section>
      </section>
      <section>
        <section class="nivel1">
          <h2>Árvores Sintáticas</h2>
          <ol class="fragment fade-up" style="float: left; margin-left: 10%">
            <li>$S$</li>
            <li>$S \rightarrow ASB$</li>
            <li>$S \rightarrow aSB$</li>
            <li>$S \rightarrow aSb$</li>
            <li>$S \rightarrow aABb$</li>
            <li>$S \rightarrow aaBb$</li>
            <li>$S \rightarrow aabb$</li>
          </ol>
          <p class="fragment fade">
            <img
              data-src="../img/as1.png"
              alt="exemplo de máquina de estados finitos"
              style="float: right; margin-left: 20%; max-width: 40%" />
          </p>
        </section>
        <section class="nivel1">
          <h2>Backus-Naur Form - BNF</h2>
          <p class="fragment fade-up">Em 1957 <a href="https://en.wikipedia.org/wiki/John_Backus"><strong>John
                Backus</strong></a>, trabalhando na IBM, criou uma linguagem para criar linguagens.
          </p>
          <p class="fragment fade-up">Representa uma gramática.</p>
          <p class="fragment fade-up">É mais simples para leitura que a álgebra.</p>
          <p class="fragment fade-up">É mais simples para escrita que a álgebra.</p>
          <p class="fragment fade-up">Finalmente virou um padrão ISO/IEC 14977 em 1996.</p>
          <p class="fragment fade-up">O criador da linguagem define como, e se usará este padrão.</p>
        </section>
        <section class="nivel1">
          <h2>BNF - Original</h2>
          <table>
              <tr><th>Símbolo</th><th>Lêmos como</th></tr>
              <tr><td>$::=$</td><td>“é definido como” ou “pode ser substituído por”</td></tr>
              <tr><td>$|$</td><td>seleção / ou</td></tr>
              <tr><td>$<>$</td><td>não terminais</td></tr>
          </table>
          <p class="fragment fade-up">Começou muito simples e com o tempo foi sendo adaptada as necessidades dos 
            criadores de linguagens.
          </p>
        </section>
        <section class="nivel1">
          <h2>BNF - Exemplo</h2>
          <ol class="fragment fade-up" style="float: left; margin-left: 10%; width: 90%;font-size: 81%;">
            <li>$\text{<𝑙𝑖𝑠𝑡𝑎> ∷= <𝑒𝑙𝑒𝑚𝑒𝑛𝑡𝑜>;<𝑙𝑖𝑠𝑡𝑎> | <𝑒𝑙𝑒𝑚𝑒𝑛𝑡𝑜>}$</li>
            <li>$\text{<𝑒𝑙𝑒𝑚𝑒𝑛𝑡𝑜>∷=<𝑙𝑒𝑡𝑟𝑎>
                  <𝑑𝑖𝑔𝑖𝑡𝑜>}$</li>
            <li>$\text{<𝑙𝑒𝑡𝑟𝑎>∷=𝐴 | 𝐵 |𝐶}$</li>
            <li>$\text{<𝑑𝑖𝑔𝑖𝑡𝑜>∷=1|2|3|4}$</li>
          </ol>
          <p class="fragment fade-up">Funciona segundo os princípios das regras de produção. Uma 
            sequência recursiva de substituição de regras permitindo a criação das sentenças da linguagem.
          </p>
        </section>
        <section class="nivel1">
          <h2>EBNF</h2>
          <ul>
            <li class="fragment fade-up" >Removeu os $<$$>$ para os símbolos não terminais.</li>
            <li class="fragment fade-up" >Símbolos termais expressos entre aspas.</li>
            <li class="fragment fade-up" >Uso $*$ para fechamento e $\{\}$ para multiplicação.</li>
            <li class="fragment fade-up" >Uso de $+$ para um ou mais.</li>
            <li class="fragment fade-up" >Uso de $?$ para seleção.</li>
            <li class="fragment fade-up" >Parênteses $()$ para agrupamento;</li>
            <li class="fragment fade-up" >Substitui $∷=$ por $=$.</li>
            <li class="fragment fade-up" >O uso da vírgula $,$ para explicitar concatenação.</li>
            <li class="fragment fade-up" >O ponto encerra uma regra.</li>
          </ul>
        </section>
        <section class="nivel1">
          <h2>BNF - Exemplo</h2>
          <p class="fragment fade-up">Considere a seguinte gramática definida em BNF</p>
          <ol  class="fragment fade-up" style="font-size: 70%">
            <li>$<𝒑𝒓𝒐𝒈𝒓𝒂𝒎> ::= 𝒃𝒆𝒈𝒊𝒏 <𝒔𝒕𝒎𝒕\_𝒍𝒊𝒔𝒕> 𝒆𝒏𝒅$</li>
            <li>$<𝒔𝒕𝒎𝒕_𝒍𝒊𝒔𝒕> ::= <𝒔𝒕𝒎𝒕> | <𝒔𝒕𝒎𝒕> ; <𝒔𝒕𝒎𝒕_𝒍𝒊𝒔𝒕>$.</li>
            <li>$<𝒔𝒕𝒎𝒕> ::= <𝒗𝒂𝒓> = <𝒆𝒙𝒑𝒓>$</li>
            <li>$<𝒆𝒙𝒑𝒓> ::= <𝒕𝒆𝒓𝒎> + <𝒕𝒆𝒓𝒎> | <𝒕𝒆𝒓𝒎> − <𝒕𝒆𝒓𝒎>$</li>
            <li>$<𝒕𝒆𝒓𝒎> ::= <𝒗𝒂𝒓> | 𝒄𝒐𝒏𝒔𝒕$</li>
            <li>$<𝒗𝒂𝒓> ::= 𝒂 | 𝒃 | 𝒄$</li>
          </ol>
          <p class="fragment fade-up">Derive o seguinte programa:</p>
          <p class="fragment fade-up">$\text{begin } a = b + \text{ const } \text{ end}$</p>
        </section>
        <section class="nivel1">
          <h2>BNF - Exemplo</h2>
          <ul style="font-size: 70%">
            <li class="fragment fade-up" >$ &lt;program&gt; \Rightarrow \emptyset$</li>
            <li class="fragment fade-up" >
              Regra 1: $ &lt;program&gt; \Rightarrow begin &lt;stmt\_list&gt;
              \text{ end}$
            </li>
            <li class="fragment fade-up" >
              Regra 2: $&lt;program&gt; \Rightarrow \text{begin } &lt;stmt&gt;
              \text{ end}$
            </li>
            <li class="fragment fade-up" >
              Regra 3: $&lt;program&gt; \Rightarrow \text{begin } &lt;var&gt;
              = &lt;expr&gt; \text{ end}$
            </li>
            <li class="fragment fade-up" >
              Regra 6: $&lt;program&gt; \Rightarrow \text{begin } a =
              &lt;expr&gt; \text{ end}$
            </li>
            <li class="fragment fade-up" >
              Regra 4: $&lt;program&gt; \Rightarrow \text{begin } a =
              &lt;term&gt; + &lt;term&gt; \text{ end}$
            </li>
            <li class="fragment fade-up" >
              Regra 5: $&lt;program&gt; \Rightarrow \text{begin } a =
              &lt;var&gt; + &ltterm&gt; \text{ end}$
            </li>
            <li class="fragment fade-up" >
              Regra 6: $&lt;program&gt; \Rightarrow \text{begin } a = b +
              &lt;term&gt; \text{ end}$
            </li>
            <li class="fragment fade-up" >
              Regra 5: $&lt;program&gt; \Rightarrow \text{begin } a = b +
              const \text{ end}$
            </li>
          </ul>
          <p class="fragment fade-up">Começamos do símbolo inicial, neste caso $ &lt;program&gt;$ e recorrentemente
            vamos procurando regras de substituição na grámática definida.
          </p>
        </section>
      </section>
      <section>
        <section class="nivel1">
          <h2>Parsers Semântica</h2>
          <p class="fragment fade-up">
            A palavra <i>parser</i>, que usaremos com frequência, tem o sentido de percorrer, varrer. 
          </p>
          <p class="fragment fade-up">Nesta disciplina: técnicas de percorrer uma árvore sintática validando a gramática.</p>
          <p class="fragment fade-up">Na literatura, o conceito de parser se confunde com o conceitos de análise sintática.
            Não são raros os parsers que fazem análise léxica, sintática e semântica.
          </p>
        </section>
        <section class="nivel1">
          <h2>Parsers</h2>
          <p class="fragment fade-up">
            <img
              data-src="../img/parsers.png"
              alt="algoritmos de parser mais comuns" />
          </p>
        </section>
        <section class="nivel1">
          <h2>Exemplo</h2>
          <p class="fragment fade-up">
            Considerando a gramática a seguir, apresente as derivações
            necessárias para encontrar “abbcde”, usando
            <strong>Bottom-up</strong> parser.
          </p>
          <ol
            class="fragment fade-up"
            style="float: left; font-size: 85%; margin-left: 10%">
            <li>$S \rightarrow aABe$</li>
            <li>$A \rightarrow Abc | b $</li>
            <li>$B \rightarrow d$</li>
          </ol>
          <p class="fragment fade" style="font-size: 85%; margin-left: 40%; max-width: 60%;">
            Regra 2: $abbcde \Rightarrow aAbcde$
          </p>
          <p class="fragment fade" style="font-size: 85%;margin-left: 40%;max-width: 60%;">
            Regra 2: $abbcde \Rightarrow aAde;$
          </p>
          <p class="fragment fade" style="font-size: 85%;margin-left: 40%;max-width: 60%;">
            Regra 3: $abbcde \Rightarrow aABe;$
          </p>
          <p class="fragment fade" style="font-size: 85%; margin-left: 40%; max-width: 60%;">
            Regra 1: $abbcde \Rightarrow S;$
          </p>
          <p class="fragment fade">A <i>string</i> “abbcde” é válida nesta gramática.</p>
        </section>
        <section class="nivel1">
          <h2>Exercício de Código</h2>
          <p>
            Vamos criar um parser para validar fórmulas de cálculo proposicional. 
            Na linguagem de programação que você desejar usando o site <a href="http://repl.it" target="_blank" rel="noopener noreferrer">Repl.it</a>
          </p>
          <ol>
            <li>Negação: $\neg P$</li>
            <li>Conjunção: $P\land Q$</li>
            <li>Disjunção: $P\lor Q$</li>
            <li>Implicação: $P\rightarrow Q$</li>
            <li>Implicação Dupla: $P\leftrightarrow Q$</li>
          </ol>
          <p style="font-size:80% !important;">
            Nosso parser deve ser recursivo e usar latex e notação rpn para a
            digitação das expressões. Segundo a seguinte gramática em EBNF
          </p>
        </section>
        <section class="nivel1">
          <h2>EBNF - Exercício</h2>
          <p>
            Vamos criar um parser para validar fórmulas de cálculo
            proposicional.
          </p>
          <ol style="font-size: 55%">
            <li>
              Formula = Constante | Proposicao | FormulaUnaria |
              FormulaBinaria
            </li>
            <li>Constante = "T" | "F"</li>
            <li>Proposicao = [a-z0-9]+</li>
            <li>
              FormulaUnaria = AbreParen\ OperadorUnario\ Formula\ FechaParen
            </li>
            <li>
              FormulaBinaria = AbreParen\ OperatorBinario\ Formula\ Formula\
              FechaParen
            </li>
            <li>AbreParen = "("</li>
            <li>FechaParen = ")"</li>
            <li>OperatorUnario = "\neg"</li>
            <li>
              OperatorBinario = "\vee" | "\wedge" | "\rightarrow" |"\leftrightarrow"
            </li>
          </ol>
          <p>Poste o link com a sua solução <a href="https://forms.gle/vhCEKNr4URwtf4RM9" target="_blank" rel="noopener noreferrer">aqui</a>.</p>
        </section>
      </section>
      <section class="nivel1">
        <section class="nivel1">
          <h1>Material de apoio</h1>
          <p class="fragment fade-up">
            Você pode baixar o material de apoio
            <a href="./INTERPRETADORES.pdf">clicando aqui</a>
          </p>
        </section>
        
      </section>
    </div>
  </div>
  <div class="home-button"><a href="https://frankalcantara.com"><i class="fas fa-home"></i></a></div>
  <script src="../../rev/reveal.js"></script>
  <script src="../../rev/plugin/notes/notes.js"></script>
  <script src="../../rev/plugin/search/search.js"></script>
  <script src="../../rev/plugin/zoom/zoom.js"></script>
  <script src="../../rev/plugin/math/math.js"></script>
  <script src="../../rev/plugin/menu/menu.js"></script>
  <script src="../../rev/plugin/chalkboard/plugin.js"></script>

  <script>
    // Full list of configuration options available at:
    // https://revealjs.com/config/
    Reveal.initialize({
      // Push each slide change to the browser history
      history: true,
      // Transition style
      transition: "default", // none/fade/slide/convex/concave/zoom
      center: false,
      math: {
        mathjax:
          "https://cdn.jsdelivr.net/gh/mathjax/mathjax@2.7.8/MathJax.js",
        config: "TeX-AMS_HTML-full",
        // pass other options into `MathJax.Hub.Config()`
        TeX: {
          Macros: {
            RR: "{\\bf R}",
          },
        },
      },
      menu: {
        side: "left",
        width: "normal",
        numbers: false,
        titleSelector: "h1, h2, h3, h4, h5, h6",
        useTextContentForMissingTitles: false,
        hideMissingTitles: false,
        markers: true,
        custom: false,
        themes: false,
        themesPath: "dist/theme/",
        transitions: false,
        openButton: true,
        openSlideNumber: false,
        keyboard: true,
        sticky: false,
        autoOpen: true,
        delayInit: false,
        openOnInit: false,
        loadIcons: true,
      },

      // reveal.js plugins
      plugins: [
        RevealNotes,
        RevealMath,
        RevealMenu,
        RevealChalkboard,
        RevealSearch,
        RevealZoom,
      ],
    });
  </script>
</body>

</html>
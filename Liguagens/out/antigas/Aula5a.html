<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="author" content="Frank Coelho de Alcantara -2020" />
  <title>Parsers</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta
    name="apple-mobile-web-app-status-bar-style"
    content="black-translucent" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" />
  <link rel="stylesheet" href="../../rev/reset.css" />
  <link rel="stylesheet" href="../../rev/reveal.css" />
  <link rel="stylesheet" href="../../rev/interpret.css" />
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section id="title-slide" class="nivel1">
        <h1 class="title">Parsers</h1>
        <p style="text-align: right !important; margin-right:2% !important;">
          Frank Coelho de Alcantara -2020
        </p>
      </section>
      <section class="nivel1">
        <section class="title-slide">
          <h2>Parsers</h2>
          <p>
            <strong>Parser</strong> é o artefato de software responsável por validar, ou produzir, uma determinada string de uma linguagem $𝐿$ Segundo a
            gramática $𝐺$ sobre o alfabeto $\Sigma$.
          </p>
          <p>Estes algoritmos estão divididos em duas grande famílias <strong>top-down</strong> e <strong>bottom-up</strong>.</p>
        </section>
        <section>
          <h2>Gramáticas Livres de Contexto</h2>
          <p class="fragment fade-up">Símbolos à esquerda são os <strong>símbolos não terminais</strong>, representados por letras latinas maiúsculas $(𝑆, 𝐴,
            𝐵, …)$.</p>
          <p class="fragment fade-up">Símbolos à direita podem ser terminais, ou não. <strong>Símbolos terminais</strong> são representados por letras latinas
            minúsculas ou outros
            símbolos $(a, b, c,
            ...)$.</p>
          <p class="fragment fade-up">Várias regras $(𝐴\rightarrow \beta_1, 𝐴\rightarrow \beta_2, …, 𝐴\rightarrow \beta_n)$, com um mesmo não terminal do
            lado esquerdo podem ser
            reunidas: $𝐴 \rightarrow \beta_1 | \beta_2 | … |\beta_n$.
          </p>
        </section>
        <section>
          <h2>Gramáticas Livres de Contexto</h2>
          <p class="fragment fade-up">Strings com terminais e não terminais são representadas por letras gregas minúsculas $(\Gamma, \Delta, \Phi,...)$.</p>
          <p class="fragment fade-up">Strings só de terminais são representadas por letras latinas mínúsculas $(w, x, y, z, ...)$.</p>
          <p class="fragment fade-up">Um símbolo qualquer, indefinido, que pode ser terminal ou não terminal, será representado por uma letra latina maiúscula
            $(𝑋, 𝑌, …)$.</p>
        </section>
        <section>
          <h2>Gramáticas Livres de Contexto</h2>
          <img data-src="../img/img1.png" class="imgleft"
            alt="símbolo meramente ilustrativo, sem valor didático" />
          <div class="textoright">
            A árvore gerada por derivação, caracteriza as gramáticas livres de contexto. Consideramos equivalentes todas as derivações que correspondem a
            mesma árvore.
          </div>
        </section>
        <section>
          <h2>Derivação</h2>
          <p class="fragment fade-up">A derivação esquerda <strong>(leftmost derivation)</strong>, em que uma regra é sempre aplicada ao primeiro não terminal
            da cadeia, o que fica mais à esquerda.</p>
          <p class="fragment fade-up">A derivação direita <strong>(rightmost derivation)</strong>, em que uma regra é sempre aplicada ao último não terminal da
            cadeia, o que fica mais à direita.</p>
        </section>
        <section>
          <h2>Ambiguidade</h2>
          <p class="fragment fade-up">Uma gramática é ambígua se, para uma string $w$ qualquer, existem duas ou mais árvores de derivação distintas, duas ou
            mais
            derivações a esquerda ou duas ou mais derivações a direita.</p>
          <p class="fragment fade-up">Podemos mostrar que uma gramática é ambígua apenas mostrando que para uma determinada string $w$ existem árvores
            distintas.</p>
        </section>
      </section>
      <!--/ introdução-->
      <section class="nivel1">
        <!-- top-down -->
        <section>
          <h2>Top-Down Parser</h2>
          <img data-src="../img/as1.png" class="imgright"
            alt="símbolo meramente ilustrativo, sem valor didático" />
          <div class="textoleft">
            Construiremos a árvore a partir da Raiz (topo) e da esquerda para direita.
            <strong>Começamos no símbolo inicial</strong>.
          </div>
        </section>
        <section>
          <h2>Exemplo</h2>
          <p>Considere a gramática a seguir e encontre a árvore de derivações para $“a + a * a”$:</p>
          <ul style="font-size: 80%;">
            <li>$\Sigma = \{ +, *, (, ), a\}$;</li>
            <li>$𝑵=\{𝑺, 𝑻, 𝑭\}$;</li>
            <li>$𝑺=\{𝑺\}$ ;</li>
            <li>$𝑷=\{ $
              <ol>
                <li>$𝑺 \rightarrow 𝑺+𝑻$;</li>
                <li>$𝑺 \rightarrow 𝑻$;</li>
                <li>$𝑻 \rightarrow 𝑻∗𝑭$;</li>
                <li>$𝑻 \rightarrow 𝑭$;</li>
                <li>$𝑭 \rightarrow (𝑺)$;</li>
                <li>$𝑭 \rightarrow 𝒂\}$;</li>
              </ol>
            </li>
          </ul>
        </section>
        <section>
          <h2>Exemplo</h2>
          <ol style="font-size:40% !important; float:right; margin-right:1%;">
            <li>$𝑷=\{𝑺 \rightarrow 𝑺+𝑻$;</li>
            <li>$𝑺 \rightarrow 𝑻$;</li>
            <li>$𝑻 \rightarrow 𝑻∗𝑭$;</li>
            <li>$𝑻 \rightarrow 𝑭$;</li>
            <li>$𝑭 \rightarrow (𝑺)$;</li>
            <li>$𝑭 \rightarrow 𝒂\}$;</li>
          </ol>

          <p class="fragment fade-up">$𝑆 \rightarrow 𝑆+𝑇$
            <strong><span style="margin-right:23%; display: block; float: right;">$𝑆 \Rightarrow 𝑆+𝑇;$</span></strong>
          </p>
          <p class="fragment fade-up">$𝑆→𝑇$<strong><span style="margin-right:23%; display: block; float: right;">$\Rightarrow
                𝑇+𝑇;$</span></strong></p>
          <p class="fragment fade-up">$𝑇→𝐹$<strong><span style="margin-right:41%; display: block; float: right;">$\Rightarrow
                𝐹+𝑇;$</span></strong></p>
          <p class="fragment fade-up">$𝐹→𝑎$<strong><span style="margin-right:41%; display: block; float: right;">$\Rightarrow
                𝑎+𝑇;$</span></strong></p>
          <p class="fragment fade-up">$𝑇→𝑇∗𝐹$<strong><span style="margin-right:33%; display: block; float: right;">$\Rightarrow
                𝑎+𝑇∗𝐹;$</span></strong></p>
          <p class="fragment fade-up">$𝑇→𝐹$<strong><span style="margin-right:33%; display: block; float: right;">$\Rightarrow
                𝑎+𝐹∗𝐹;$</span></strong></p>
          <p class="fragment fade-up">$𝐹→𝑎$<strong><span style="margin-right:33%; display: block; float: right;">$\Rightarrow
                𝑎+𝑎∗𝐹;$</span></strong></p>
          <p class="fragment fade-up">$𝐹→𝑎$<strong><span style="margin-right:33%; display: block; float: right;">$\Rightarrow
                𝑎+𝑎∗𝑎;$</span></strong></p>
        </section>
        <section>
          <h2>Exemplo</h2>
          <img data-src="../img/as2.png" class="imgright"
            alt="símbolo meramente ilustrativo, sem valor didático" />
          <p>$𝑆 \rightarrow 𝑆+𝑇$
            <strong><span style="margin-right:12%; display: block; float: right;">$𝑆 \Rightarrow 𝑆+𝑇;$</span></strong>
          </p>
          <p>$𝑆→𝑇$<strong><span style="margin-right:12%; display: block; float: right;">$\Rightarrow
                𝑇+𝑇;$</span></strong></p>
          <p>$𝑇→𝐹$<strong><span style="margin-right:12%; display: block; float: right;">$\Rightarrow
                𝐹+𝑇;$</span></strong></p>
          <p>$𝐹→𝑎$<strong><span style="margin-right:12%; display: block; float: right;">$\Rightarrow
                𝑎+𝑇;$</span></strong></p>
          <p>$𝑇→𝑇∗𝐹$<strong><span style="margin-right:4%; display: block; float: right;">$\Rightarrow
                𝑎+𝑇∗𝐹;$</span></strong></p>
          <p>$𝑇→𝐹$<strong><span style="margin-right:4%; display: block; float: right;">$\Rightarrow
                𝑎+𝐹∗𝐹;$</span></strong></p>
          <p>$𝐹→𝑎$<strong><span style="margin-right:40%; display: block; float: right;">$\Rightarrow
                𝑎+𝑎∗𝐹;$</span></strong></p>
          <p>$𝐹→𝑎$<strong><span style="margin-right:40%; display: block; float: right;">$\Rightarrow
                𝑎+𝑎∗𝑎;$</span></strong></p>
        </section>

        <section>
          <h2>Leftmost / Rightmost</h2>
          <ol style="font-size:40% !important; float:right; margin-right:2%;">
            <li>$𝑷=\{𝑺 \rightarrow 𝑺+𝑻$;</li>
            <li>$𝑺 \rightarrow 𝑻$;</li>
            <li>$𝑻 \rightarrow 𝑻∗𝑭$;</li>
            <li>$𝑻 \rightarrow 𝑭$;</li>
            <li>$𝑭 \rightarrow (𝑺)$;</li>
            <li>$𝑭 \rightarrow 𝒂\}$;</li>
          </ol>
          <div style="float: left; margin-left: 12%;">
            <p>Leftmost</p>
            <small>
              <p><strong>$𝑆 \Rightarrow 𝑆+𝑇;$</strong></p>
              <p><strong>$\Rightarrow 𝑇+𝑇;$</strong></p>
              <p><strong>$\Rightarrow 𝐹+𝑇;$</strong></p>
              <p><strong>$\Rightarrow 𝑎+𝑇;$</strong></p>
              <p><strong>$\Rightarrow 𝑎+𝑇∗𝐹;$</strong></p>
              <p><strong>$\Rightarrow 𝑎+𝐹∗𝐹;$</strong></p>
              <p><strong>$\Rightarrow 𝑎+𝑎∗𝐹;$</strong></p>
              <p><strong>$\Rightarrow 𝑎+𝑎∗𝑎;$</span></strong></p>
            </small>
          </div>
          <div style="float: right; margin-right: 23%;">
            <p>Rightmost</p>
            <small>
              <p><strong>$𝑆 \Rightarrow 𝑆+𝑇;$</strong></p>
              <p><strong>$\Rightarrow 𝑆+𝑇∗𝐹;$</strong></p>
              <p><strong>$\Rightarrow 𝑆+𝑇∗𝑎;$</strong></p>
              <p><strong>$\Rightarrow 𝑆+𝐹∗𝑎;$</strong></p>
              <p><strong>$\Rightarrow 𝑆+𝑎∗𝑎;$</strong></p>
              <p><strong>$\Rightarrow 𝑇+𝑎∗𝑎;$</strong></p>
              <p><strong>$\Rightarrow 𝐹+𝑎∗𝑎;$</strong></p>
              <p><strong>$\Rightarrow 𝑎+𝑎∗𝑎;$</span></strong></p>
            </small>
          </div>
        </section>
        <section>
          <h2>Pratica 1</h2>
          <p>Considere o exemplo anterior e verifique se as duas derivações produzem a mesma árvore.</p>
          <p>Tente encontrar outra derivação para criar uma árvore diferente.</p>
          <p>Discuta seus resultados com seus colegas de classe e apresente para o professor.</p>
        </section>
      </section>
      <!--/ top-down -->
      <!-- Bottom-up -->
      <section class="nivel1">
        <section>
          <h2>Bottom-up Parser</h2>
          <img data-src="../img/as1.png" class="imgright"
            alt="símbolo meramente ilustrativo, sem valor didático" />
          <div class="textoleft">
            Construiremos a árvore a partir das folhas e da esquerda para direita.
            <strong>Terminaremos no símbolo inicial</strong>.
          </div>
        </section>
        <section>
          <h2>Bottom-up Parser</h2>
          <p>Considere uma string $w$ qualquer: </p>
          <p>1. Escolha uma substring $\beta $ de tal forma que: $\beta $ seja o fator mais a esquerda de $w$ desde que exista uma regra de produção
            $𝐴\rightarrow𝛽$.</p>
          <p>2. Troque $\beta $ por $𝐴$ em $w$.</p>
          <p>3. Repita até chegar ao símbolo inicial.</p>
        </section>
        <section>
          <h2>Exemplo</h2>
          <p> Considere a gramática definida a seguir e encontre a derivação que prove que “abbcde” pertence a linguagem definida por esta gramática.</p>
          <ul style="font-size: 80%;">
            <li>$\Sigma = \{ a, b, c, d, e\}$;</li>
            <li>$𝑵=\{𝑺, A, B\}$;</li>
            <li>$𝑺=\{𝑺\}$ ;</li>
            <li>$𝑷=\{ $
              <ol>
                <li>$𝑺 \rightarrow 𝒂𝑨𝑩𝒆$;</li>
                <li>$A \rightarrow 𝑨𝒃𝒄$;</li>
                <li>$A \rightarrow b$;</li>
                <li>$B \rightarrow d$;</li>
              </ol>
            </li>
          </ul>
        </section>

        <section>
          <h2>Exemplo</h2>
          <ol style="font-size:40% !important; float:right; margin-right:2%;">
            <li>$𝑺 \rightarrow 𝒂𝑨𝑩𝒆$;</li>
            <li>$A \rightarrow 𝑨𝒃𝒄$;</li>
            <li>$A \rightarrow b$;</li>
            <li>$B \rightarrow d$;</li>
          </ol>
          <table style="font-size: 80%;">
            <tr>
              <th>Strings</th>
              <th>Produções</th>
              <th>Escolha</th>
            </tr>
            <tr>
              <td>$abbcde$</td>
              <td>$𝑨 \rightarrow 𝒃$</td>
              <td></td>
            </tr>
            <tr>
              <td></td>
              <td>$𝑩 \rightarrow 𝒅$</td>
              <td>$𝑨 \rightarrow 𝒃$</td>
            </tr>
            <tr>
              <td>$aAbcde$</td>
              <td>$𝑨 \rightarrow 𝑨𝒃𝒄$</td>
              <td></td>
            </tr>
            <tr>
              <td></td>
              <td>$𝑨 \rightarrow 𝒃$</td>
              <td></td>
            </tr>
            <tr>
              <td></td>
              <td>$𝑩 \rightarrow 𝒅$</td>
              <td>$𝑨 \rightarrow 𝑨𝒃𝒄$</td>
            </tr>
            <tr>
              <td>$aAde$</td>
              <td>$𝑩 \rightarrow 𝒅$</td>
              <td>$𝑩 \rightarrow 𝒅$</td>
            </tr>
            <tr>
              <td>$aABe$</td>
              <td>$𝑺 \rightarrow 𝒂𝑨𝑩𝒆$</td>
              <td>$𝑺 \rightarrow 𝒂𝑨𝑩𝒆$</td>
            </tr>
            <tr>
              <td>$S$</td>
              <td></td>
              <td></td>
            </tr>
          </table>
        </section>
        <section>
          <h2>Shift Reduce</h2>
          <p class="fragment fade-up">Os parsers desta categoria também são chamados de SR Parsers (Shift-Reduce). Onde: </p>
          <p class="fragment fade-up"><strong>Shift</strong>: leia o próximo símbolo;</p>
          <p class="fragment fade-up"><strong>Reduce</strong>: uma substring $w$ correspondente ao lado direito de uma regra será substituída.</p>
        </section>
        <section>
          <h2>Gerando Parsers</h2>
          <p class="fragment fade-up">
            Um gerador de parsers, geralmente, converte uma gramática definida em <strong>EBNF</strong> em tabelas. A forma destas
            tabelas depende da família de parser escolhida (<strong>top-down</strong>,<strong>bottom-up</strong>).
          </p>
          <p class="fragment fade-up">Em tempo de compilação os <strong>tokens</strong> originados do analisador léxico são lidos, a tabela consultada e o
            parser criado.
          </p>
        </section>

        <section>
          <h2>Bottom-up Algoritmo</h2>
          <p class="fragment fade-up">Vamos colocar símbolos na pilha até que a pilha tenha tantos símbolos quanto necessário para reconhecer o lado
            direito de uma regra de produção. Assim
            que isso acontecer faremos a troca destes símbolos pelo não terminal correspondente.</p>
          <p class="fragment fade-up">A sequência de símbolos na pilha que está pronta para ser reduzida é chamada de <strong>handle</strong>.</p>
          <p class="fragment fade-up">O <strong>handle</strong> é o lado direito de uma regra de produção segundo determinado pela gramática. </p>
        </section>
        <section>
          <h2>Shift Reduce</h2>
          <p class="fragment fade-up"><strong>Shift</strong>: o símbolo corrente na pilha e lê o próximo símbolo.</p>
          <p class="fragment fade-up"><strong>Reduce</strong>: o conteúdo da pilha usando uma regra de produção.</p>
          <p class="fragment fade-up">O nome desta técnica é <strong>Handle Pruning</strong>.</p>
        </section>
        <section>
          <h2>Handle Prunning</h2>
          <p class="fragment fade-up"><strong>Pilha</strong>, ou <strong>stack</strong>, armazena os símbolos que serão substituídos.</p>
          <p class="fragment fade-up"><strong>Buffer</strong>, contendo os outros símbolos. Aqueles que ainda serão avaliados.</p>
          <p class="fragment fade-up"><strong>Table</strong>, contendo as regras e os passos que estão ocorrendo.</p>
        </section>
        <section>
          <h2>Handle Prunning 2</h2>
          <p class="fragment fade-up">Dado um string $w$ teremos o seguinte estado inicial:</p>
          <table class="fragment fade-up" style="font-size: 80%;">
            <tr>
              <th>Pilha</th>
              <th>Buffer</th>
            </tr>
            <tr>
              <td>$\$$</td>
              <td>$w\$$</td>
            </tr>
          </table>
          <p class="fragment fade-up">Onde o $\$$ marca o início da pilha e o fim do buffer.</p>
        </section>
        <section>
          <h2>Handle Prunning 3</h2>
          <p class="fragment fade-up"><strong>Shift</strong>, o próximo símbolo é colocado no topo da pilha.</p>
          <p class="fragment fade-up"><strong>Reduce</strong>, o parser:</p>
          <ol class="fragment fade-up" style="font-size:80%; margin-left:2%; width:90%;">
            <li>Sabe que o extremo direito do handle está na topo da pilha;</li>
            <li>Localiza o estremo esquerdo do handle na pilha e</li>
            <li>Decide qual símbolo não terminal irá substituir o handle.</li>
          </ol>
          <p class="fragment fade-up"><strong>Accept</strong>, o parser acabou com sucesso.</p>
          <p class="fragment fade-up"><strong>Error</strong>, o parser encontrou um erro de sintaxe.</p>
        </section>
        <section>
          <h2>Handle Prunning Exemplo</h2>
          <p class="fragment fade-up">Considere a gramática definida pelo seguinte conjunto de regras de produção e encontre a derivação para “a + a * a”.
          </p>
          <ol class="fragment fade-up">
            <li>$𝑺 \rightarrow 𝑺+𝑺;$</li>
            <li>$𝑺 \rightarrow 𝑺∗𝑺;$</li>
            <li>$𝑺 \rightarrow (𝑺)$</li>
            <li>$𝑺 \rightarrow 𝒂$</li>
          </ol>
        </section>
        <section>
          <h2>Handle Prunning Exemplo</h2>
          <ol style="font-size:40% !important; float:right; margin-right:2%;">
            <li>$𝑺 \rightarrow 𝑺+𝑺;$</li>
            <li>$𝑺 \rightarrow 𝑺∗𝑺;$</li>
            <li>$𝑺 \rightarrow (𝑺)$</li>
            <li>$𝑺 \rightarrow 𝒂$</li>
          </ol>
          <table style="font-size: 60%;">
            <tr>
              <th>Pilha</th>
              <th>Buffer</th>
              <th>Ação</th>
            </tr>
            <tr>
              <td>$\$$</td>
              <td>$ a+a*a\$$</td>
              <td>Shift</td>
            </tr>
            <tr>
              <td>$\$a$</td>
              <td>$+a*a\$$</td>
              <td>Reduce $S \rightarrow a$</td>
            </tr>
            <tr>
              <td>$\$S$</td>
              <td>$+a*a\$$</td>
              <td>Shift</td>
            </tr>
            <tr>
              <td>$\$S+$</td>
              <td>$a*a\$$</td>
              <td>Shift</td>
            </tr>
            <tr>
              <td>$\$S+a$</td>
              <td>$*a\$$</td>
              <td>Reduce $S \rightarrow a$</td>
            </tr>
            <tr>
              <td>$\$S+S$</td>
              <td>$*a\$$</td>
              <td>Shift</td>
            </tr>
            <tr>
              <td>$\$S+S*$</td>
              <td>$a\$$</td>
              <td>Shift</td>
            </tr>
            <tr>
              <td>$\$S+S*a$</td>
              <td>$\$$</td>
              <td>Reduce $S \rightarrow a$</td>
            </tr>
            <tr>
              <td>$\$S+S*S$</td>
              <td>$\$$</td>
              <td>Reduce $S \rightarrow S*S$</td>
            </tr>
            <tr>
              <td>$\$S+S$</td>
              <td>$\$$</td>
              <td>Reduce $S \rightarrow S+S$</td>
            </tr>
            <tr>
              <td>$\$S$</td>
              <td>$\$$</td>
              <td>Accept</td>
            </tr>
          </table>
        </section>
        <section>
          <h2>Prática 2 </h2>
          <p>Refaça este exemplo cuidadosamente veja se é possível encontrar outra sequência de substituição.</p>
          <p>Se encontrar outra sequência de substituição. As árvores sintáticas serão iguais?</p>
          <p>Compare seus achados com os achados dos seus colegas de classe.</p>
        </section>
        <section>
          <h2>Desafio</h2>
          <p><a href="./ExercParser1Formativo.pdf">Clique aqui</a> para acessar um exercício. Mais que isso, um desafio a sua capacidade de entender este
            processo.</p>
          <p>Se realizar o desafio, me envie. Terei muito prazer em comentar seus achados.</p>
        </section>
      </section>
      <section class="nivel1">
        <section>
          <h2>Parsers</h2>
          <p>
            <img
              data-src="../img/parsers.png"
              alt="algoritmos de parser mais comuns" />
          </p>
        </section>

        <section>
          <h2>Parsers - Top-Down</h2>
          <img
            data-src="../img/tpdn1.png" style="float: left; margin-left: 2%; max-width: 465px;"
            alt="algoritmos de parser mais comuns" />
          <div style=" font-size: 80%; float: left; margin-right: 1%; margin-left: 4%; max-width: 44%; padding-top: 3%;">
            <ul>
              <li>Da raiz para as folhas;</li>
              <li>Da esquerda para direita;</li>
              <li>A derivação mais a esquerda;</li>
              <li>O parse deverá escolher uma regra que atenda esta derivação.</li>
            </ul>
            <p>O que acontece quando não existe uma regra adequada?</p>
          </div>
        </section>
        <section>
          <h2>Parsers - Backtracing</h2>
          <img
            data-src="../img/tpdn1.png" style="float: left; margin-left: 2%; max-width: 465px;"
            alt="algoritmos de parser mais comuns" />
          <div style=" font-size: 80%; float: left; margin-right: 1%; margin-left: 4%; max-width: 44%; padding-top: 3%;">
            <p>Se, a qualquer momento, não existir uma regra de produção que permita a derivação, o parser deve voltar e refazer a árvore;
              A essa operação damos o nome de Backtrack.</p>
          </div>
        </section>
        <section>
          <h2>Parsers - Backtracing</h2>
          <img
            data-src="../img/tpdn1.png" style="float: left; margin-left: 2%; max-width: 465px;"
            alt="algoritmos de parser mais comuns" />
          <div style=" font-size: 80%; float: left; margin-right: 1%; margin-left: 4%; max-width: 44%; padding-top: 3%;">
            <p>Existem dois algoritmos para varrer uma árvore de soluções: <strong>deep-first</strong> e <strong>breadth-first</strong>.</p>
            <p>No <strong>deep-first</strong> havendo duas opções, armazenamos uma e seguimos com a outra, se algo der errado voltamos neste ponto e seguimos a
              outra alternativa.
            </p>
          </div>
        </section>
        <section>
          <h2>Parsers - Backtracing</h2>
          <img
            data-src="../img/tpdn1.png" style="float: left; margin-left: 2%; max-width: 465px;"
            alt="algoritmos de parser mais comuns" />
          <div style=" font-size: 80%; float: left; margin-right: 1%; margin-left: 4%; max-width: 44%; padding-top: 3%;">
            <p>No <strong>breadth-first</strong>, armazenamos um conjunto de soluções parciais e examinamos estas soluções em busca de soluções melhores
              eventualmente o conjunto
              irá conter toda a árvore.</p>
          </div>
        </section>
        <section>
          <h2>Parsers - NonBacktracing</h2>
          <img
            data-src="../img/tpdn1.png" style="float: left; margin-left: 2%; max-width: 465px;"
            alt="algoritmos de parser mais comuns" />
          <div style=" font-size: 80%; float: left; margin-right: 1%; margin-left: 4%; max-width: 44%; padding-top: 3%;">
            <p>Classe de parsers que usa um ponteiro apontando para o próximo símbolo na string;</p>
            <p>Usam uma classe de gramática especial chamada de LL(k);</p>
            <p>O k representa o número de símbolos previsto.</p>
          </div>
        </section>
        <section>
          <h2>Gramáticas LL(1)</h2>
          <img
            data-src="../img/tpdn1.png" style="float: left; margin-left: 2%; max-width: 465px;"
            alt="algoritmos de parser mais comuns" />
          <div style=" font-size: 60%; float: left; margin-right: 1%; margin-left: 4%; max-width: 44%; padding-top: 3%;">
            <p>De tal forma que:$𝑮=\{𝑵,\Sigma, 𝑷, 𝑺\}$</p>
            <p>Onde: $𝒘 \in \Sigma^∗, 𝑨\in 𝑵, \alpha, \beta 𝒆 \gamma \in (𝑵\cup \Sigma)^∗$</p>
            <p>Cujas derivações serão dadas por:$𝑺 \rightarrow 𝒘𝑨 \gamma | 𝒘 \alpha 𝜸 | 𝒘𝒙 \in \Sigma^∗$ </p>
            <p>$ 𝑺 \rightarrow 𝒘𝑨 \gamma | 𝒘\beta \gamma | 𝒘𝒚 \in \Sigma^∗$
            </p>
          </div>
        </section>
        <section>
          <h2>LL(k) - Resumo</h2>
          <p>
            <img
              data-src="../img/llk1.png"
              alt="algoritmos de parser mais comuns" />
          </p>
        </section>

      </section>
      <section class="nivel1">
        <section>
          <h1>Material de apoio</h1>
          <p>
            Você pode baixar o material de apoio
            <a href="./INTERPRETADORES.pdf">clicando aqui</a>
          </p>
        </section>
        <section>
          <h2>Obras Citadas</h2>
          <p>
            AHO, A. V. et al.
            <strong>Compiladores: princípios, técnicas e ferramentas</strong>.
            2º. ed. Boston, MA, USA: Pearson Education Inc. , 2007. <br />
            CASS, S. <strong>The 2016 Top Programming Languages</strong>. IEEE
            Spectrum, 2016. Disponível em: <http:
              //spectrum.ieee.org/computing/software/the-2016-top-programming-languages>.
              Acesso em: 22 Set. 2016.
          </p>
        </section>
      </section>
    </div>
  </div>
  <div class="home-button"><a href="https://frankalcantara.com"><i class="fas fa-home"></i></a></div>
  <script src="../../rev/reveal.js"></script>
  <script src="../../rev/plugin/notes/notes.js"></script>
  <script src="../../rev/plugin/search/search.js"></script>
  <script src="../../rev/plugin/zoom/zoom.js"></script>
  <script src="../../rev/plugin/math/math.js"></script>
  <script src="../../rev/plugin/menu/menu.js"></script>
  <script src="../../rev/plugin/chalkboard/plugin.js"></script>

  <script>
    // Full list of configuration options available at:
    // https://revealjs.com/config/
    Reveal.initialize({
      // Push each slide change to the browser history
      history: true,
      // Transition style
      transition: "fade", // none/fade/slide/convex/concave/zoom
      center: false,
      math: {
        mathjax:
          "https://cdn.jsdelivr.net/gh/mathjax/mathjax@2.7.8/MathJax.js",
        config: "TeX-AMS_HTML-full",
        // pass other options into `MathJax.Hub.Config()`
        TeX: {
          Macros: {
            RR: "{\\bf R}",
          },
        },
      },
      menu: {
        side: "left",
        width: "normal",
        numbers: false,
        titleSelector: "h1, h2, h3, h4, h5, h6",
        useTextContentForMissingTitles: false,
        hideMissingTitles: false,
        markers: true,
        custom: false,
        themes: false,
        themesPath: "dist/theme/",
        transitions: false,
        openButton: true,
        openSlideNumber: false,
        keyboard: true,
        sticky: false,
        autoOpen: true,
        delayInit: false,
        openOnInit: false,
        loadIcons: true,
      },

      // reveal.js plugins
      plugins: [
        RevealNotes,
        RevealMath,
        RevealMenu,
        RevealChalkboard,
        RevealSearch,
        RevealZoom,
      ],
    });
  </script>
</body>

</html>
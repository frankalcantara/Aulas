<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="author" content="Frank Coelho de Alcantara -2020">
  <title>Linguagens Formais - MEF e Regex</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta
    name="apple-mobile-web-app-status-bar-style"
    content="black-translucent" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" />
  <link rel="stylesheet" href="../../rev/reset.css" />
  <link rel="stylesheet" href="../../rev/reveal.css" />
  <link rel="stylesheet" href="../../rev/aulas.css" />
  <link rel="stylesheet" href="../../rev/interpret.css" />
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section id="title-slide" class="nivel1">
        <h1 class="title">Linguagens Formais <br /> MEF & Regex</h1>
        <p class="author" style="text-align: right !important;">Frank Coelho de Alcantara - 2020 &nbsp; &nbsp; &nbsp;</p>
      </section>
      <section>
        <section class="nivel1">
          <h2>Definição</h2>
         <small style="font-size: 93% !important;">
          <p  class="fragment fade-up">
            <strong>Linguagem Formal</strong>: um conjunto de itens de uma linguagem regular é uma coleção <strong>finita</strong> de ítens que 
            podem ser definidos por meio de um
            alfabeto $\Sigma$ e contém as <i>strings</i> $\emptyset$, $\{\varepsilon\}$ e $\{a\}$ para todo e qualquer $a \in \Sigma$.
         </p>
         <p  class="fragment fade-up">
            <strong>Linguagem Regular</strong>: um conjunto de itens de uma linguagem regular é uma coleção <strong>finita</strong>
            de ítens que
            podem ser definidos por meio de um
            alfabeto $\Sigma$ e contém as <i>strings</i> $\emptyset$, $\{\varepsilon\}$ e $\{a\}$ para todo e qualquer $a \in
            \Sigma$.
            Este conjunto é fechado em relação as operações de <strong>união</strong>, <strong>concatenação</strong> e
            <strong>fechamento de Kleene</strong>.
          </p>
          </small>
        </section>
        <section class="nivel1">
          <h2>Linguagens Formais e Regulares </h2>
          <p  class="fragment fade-up">
            Linguagens formais são aquelas que podem ser definidas por máquinas de estado finito, determinísticas ou não, e 
            por expressões regulares. Atendendo ao <strong>Teorema de Kleene</strong> .</br>
            Isto significa que podemos criar uma máquina de estado finito <strong>(MEF)</strong> equivalente a uma expressão 
            regular <strong>(Regex)</strong> ou uma expressão regular equivalente a uma máquina de estados finitos. 
            De tal forma que: $$MEF \equiv Regex$$
          </p>
        </section>
      </section>
      <section>
      
        <section class="nivel1">
          <h2>Máquinas de Estado Finito</h2>
          <p  class="fragment fade-up"> Um máquina de estados finitos é uma abstração matemática definida pela 5-tupla, com apenas cinco
            conceitos:</p>
          <ol style=" width: 91%; font-size: 83%; margin-left: 7%; margin-right: 9%;">
            <li  class="fragment fade-up">$S$: um conjunto finito de estados;</li>
            <li  class="fragment fade-up">$\Sigma$: um alfabeto de entrada finito;</li>
            <li  class="fragment fade-up">$\delta: S\times \Sigma \rightarrow S$: um conjunto finito funções de transição;</li>
            <li  class="fragment fade-up">$s_0$: um estado inicial;</li>
            <li  class="fragment fade-up">$A \subseteq S$: um conjunto finito de estados de aceitação;</li>
          </ol>
          <p  class="fragment fade-up">$$MEF=\{S, \Sigma, \delta, s_0, A\}$$</p>
        </section>
        <section class="nivel1">
          <h2>Estados e Transições</h2>
          <small style=" font-size: 80%!important;">
          <p class="fragment fade-up"><strong>Estados:</strong> pontos estáveis no processo de computação, representados por círculos.</p>
          <p class="fragment fade-up"><strong>Estado inicial:</strong> estado onde a máquina inicia o processamento, um estado com uma seta apontada para ele.</p>
          <p class="fragment fade-up"><strong>Estados intermediários:</strong> todos os estados intermediários no processamento.</p>
          <p class="fragment fade-up"><strong>Estado final:</strong> se a string for corretamente processada, a máquina deverá assumir este estado.</p>
          <p class="fragment fade-up"><strong>Transições:</strong> ato de mudar de um estado para outro durante a computação. Representadas por uma seta com origem em um estado e destino no estado seguinte.</p>
          </small>
        </section>
        <section class="nivel1">
          <h2>Conceitos Adicionais</h2>
          <p  class="fragment fade-up">
            $\Sigma^*$ é o conjunto de todos os <i>strings</i>, de comprimento maior que $0$ que
            podem ser criadas a partir de $\Sigma$.
          </p>
          <p  class="fragment fade-up">$L(MEF)=\{w|\delta^*(s_0,w)\in A\}$ é o conjunto de todas as <i>strings</i> aceitas por $MEF$.</p>
          <p  class="fragment fade-up">Chamamos o conjunto $L(MEF)$ de Linguagem da $MEF$.</p>
        </section>
        <section class="nivel1">
          <h2>Aceitação ou identificação</h2>
          <p  class="fragment fade-up">
            Uma <i>string</i> $w$ será aceita por uma $MEF$ se, e somente se, depois que $MEF$ terminar o
            processamento de $w$, $MEF$ esteja parada em um dos estados de aceitação do conjunto $A$ que define esta máquina.
          </p>
          <p class="fragment fade-up">
            Neste caso, dizemos que a $MEF$ aceita a <strong>string</strong> $w$.
          </p>
        </section>
        <section class="nivel1">
          <h2>Representação</h2>
          <p  class="fragment fade-up">Podemos representar uma $MEF$ com três notações diferentes:</p>
          <ol>
            <li class="fragment fade-up">Uma lista de elementos na $5-tupla$.</li>
            <li class="fragment fade-up">Uma tabela de transição.</li>
            <li class="fragment fade-up">Um diagrama de transição.</li>
          </ol>
          <p class="fragment fade-up">Caberá a você escolher a representação mais adequada para resolver o problema, ou 
            a representação mais adequada para o seu entendimento do problema.</p>
        </section>
        <section class="nivel1">
          <h2>Algebricamente</h2>
          <p  class="fragment fade-up">$MEF=\{S, \Sigma, \delta, s_0, A\}$</p>
          <p  class="fragment fade-up">$MEF=\{\{s_0, s_1, s_2\}, \{0,1\}\\ \{\delta_{(s_0,0)}=s_1, \\ \delta_{(s_0,1)}=s_0, \\
            \delta_{(s_1,0)}=s_2, \\ \delta_{(s_1,1)}=s_0, \\ \delta_{(s_2,0)}=s_2, \\ \delta_{(s_2,1)}=s_0\}, s_0 =
            s_0, A=\{s_2\} \}$</p>
        </section>
        <section class="nivel1">
          <h2>Tabela de Transição</h2>
          <table class="blueTable">
            <thead>
              <tr>
                <th>$\delta$</th>
                <th>$0$</th>
                <th>$1$</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>$s_0$</td>
                <td>$s_1$</td>
                <td>$s_0$</td>
              </tr>
              <tr>
                <td>$s_1$</td>
                <td>$s_2$</td>
                <td>$s_0$</td>
              </tr>
              <tr>
                <td>$s_2$</td>
                <td>$s_2$</td>
                <td>$s_0$</td>
              </tr>
            </tbody>
          </table>
          <p  class="fragment fade-up">Existem pelo menos duas formas de se representar uma tabela de transição. <a href="https://forms.gle/hrY7Z7ZWFc7ENYaP9" target="_blank" rel="noopener noreferrer">Clique aqui</a> para explicar que formas são estas e qual a diferença entre elas.</p>
        </section>
        <section class="nivel1">
          <h2>Diagrama de Transição</h2>
          <p>Existem várias formas de se representar o diagrama de transição. Nesta disciplina usaremos:</p>
          <p  class="fragment fade-up">
            <img data-src="../img/exemploMEF.jpg" style=" float: left; margin-left: 11%; height: 300px;" alt="exemplo de máquina de estados finitos" /> </p>
        </section>
        <section class="nivel1">
          <h2>Exemplo 1</h2>
          <p  class="fragment fade-up">Uma máquina de estados comum em ambientes de comunicação de 
          dados é a máquina de detecção de paridade. 
          Este tipo de máquina é capaz de detectar a paridade de um conjunto de bits, fornecidos como
          entrada de forma sequêncial.</p>
          
          <p class="fragment fade-up">Esta máquina conta o número de símbolos $1$ em uma string do 
          alfabeto $\Sigma_{bin} =\{0,1\}$. Qualquer número para de $1$ é paridade par. Lembre-se nenhum $1$ é par. 
          Coisas das regras de paridade.</p>
          
          <p class="fragment fade-up"> <a href="https://automatonsimulator.com/" target="_blank" rel="noopener noreferrer">Clique aqui para simular.</a> </p>
        </section>
        <section class="nivel1">
          <h2>Exemplo 2</h2>
          <p class="fragment fade-up">Cabe a você fazer uma máquina de paridade ímpar. Esta máquina irá receber uma 
            linguagem definida pelo alfabeto $\Sigma_{bin} =\{0,1\}$ e reconhecer todos os <strong>strings</strong>
          cuja paridade seja ímpar. Ou seja, que o número de símbolos $1$ em uma determinada <strong>string</strong> seja 
          ímpar</p>
          <p class="fragment fade-up">Lembre-se nenhum $1$ é par.</p>
          <p class="fragment fade-up"> <a href="https://forms.gle/KS6yEmkmvsSfaUtA7" target="_blank" rel="noopener noreferrer">Clique aqui</a> e envie sua simulação para revisão</p>
        </section>
      </section>
      <section>
          <section class="nivel1">
            <h2>Pausa para o Gatinho </h2>
            <img style="display: block; margin-left: auto; margin-right: auto; width: 70%;" data-src="../img/gato1.jpg"
              alt="grace hopper e uma equipe de engenheiros trabalhando no univac" />
            <span style=" font-size: 65% !important;">Foto de <a
                href="https://unsplash.com/@screenwork_ch?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Marcel
                Friedrich</a> on <a
                href="https://unsplash.com/s/photos/cat-and-computers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></span>
          </section>
        <section class="nivel1">
          <h2>Teorema de Kleene</h2>
            <p  class="fragment fade-up">O Teorema de <a href="https://en.wikipedia.org/wiki/Stephen_Cole_Kleene" target="_blank" rel="noopener noreferrer">Kleene</a> afirma
            que, para que uma linguagem seja considerada formal, ela deve ser definida por: expressões
            regulares e máquinas de estado finitas.</p>
          <p  class="fragment fade-up">Isto significa que, com um pouco de álgebra é possível transformar uma em outra.</p>
          <p class="fragment fade-up">Hardware em Software?.</p>
        </section>
        <section class="nivel1">
          <h2>Expressões Regulares</h2>
          <p  class="fragment fade-up">Expressões regulares são uma notação algébrica, criada por Stephen Kleene, 
            para representar uma determinada linguagem $L$ dado um alfabeto $\Sigma$ qualquer. </p> 
          <p  class="fragment fade-up"><strong> A nós interessam as linguagens regulares.</strong></p>
          <p  class="fragment fade-up">As Linguagens regulares são as linguagens formais que são fechadas nas operações de <strong>união</strong>, 
          <strong>concatenação</strong> e <strong>fechamento de Kleene</strong>.</p>
        </section>
        <section class="nivel1">
          <h2>Fechamento - Closure</h2>
          <small style="font-size: 80% !important;">
          <p  class="fragment fade-up">Dizemos que um determinado conjunto $A$ é fechado em relação a uma operação $OP$. 
              Se, e somente se, quando aplicamos a operação $OP$ a qualquer item do conjunto $A$ o resultado continua sendo parte do conjunto $A$.</p>
            <p  class="fragment fade-up">A operação $OP$ altera o item mas o resultado desta alteração ainda é parte do conjunto $A$.
                A multiplicação altera o item, mas, o resultado, ainda faz parte do conjunto dos inteiros. </p>
            <p class="fragment fade-up"> O conjunto dos inteiros é <strong>fechado em relação soma, subtração e multiplicação</strong>. Contudo, não
                é fechado em relação a divisão.</p>
            <p class="fragment fade-up"> O resultado de algumas divisões executadas entre inteiros, não faz parte do conjunto dos inteiros.</p>
          </small>
        </section>
        <section class="nivel1">
          <h2>União</h2>
          <p  class="fragment fade-up">Dados os conjunto $L_1=\{a,b,c,eg,hf\}$ e $L_2=\{ea,af\}$ definimos a união entre estes conjuntos como:</p>
          <p class="fragment fade-up" style="text-align:center !important;"> $L_1 \cup L_2=\{a,b,c,eg,hf,ea,af\}$</p>
          <p  class="fragment fade-up">Em algumas disciplinas usamos o símbolo $+$ para representar a união, se for o caso, teremos: </p>
          <p class="fragment fade-up" style="text-align:center !important;"> $L_1 + L_2=\{a,b,c,eg,hf,ea,af\}$</p>
          <p class="fragment fade-up">Em outros casos podemos usar uma barra vertical $|$ para representar a união.</p>
        </section>
        <section class="nivel1">
          <h2>Concatenação</h2>
          <p  class="fragment fade-up">Definimos a concatenação entre dois conjuntos $ L_1 \land L_2 $ como:</p>
          <p class="fragment fade-up" style="text-align:center !important;"> $ L= L_1 \cdot L_2 = \{ xy | x \in L_1, y \in L_2 \}$</p>
          <p  class="fragment fade-up">Não é coincidência o uso do símbolo do produto escalar para representar a concatenação.</p>
          <p class="fragment fade-up">O produto escalar representa perfeitamente a operação de concatenação entre dois conjuntos.</p>
        </section>
        <section class="nivel1">
          <h2>Concatenação - Exemplos</h2>
          <p  class="fragment fade-up">As casas do Tabuleiro de Xadrez são nomeadas usando o conjunto resultado da operação entre $ L_1 \land L_2 $
            desde que:</p>
          <p class="fragment fade-up" style="font-size:75% !important; text-align:center !important;"> $ L_1 = \{ a, b, c, d, e, f, g, h \} \land L_2 = \{ 1, 2, 3, 4, 5,
            6, 7, 8 \}$</p>
          <p  class="fragment fade-up">Contudo, as casas jámais são nomeadas usando o conjunto:</p>
          <p class="fragment fade-up" style="font-size:75% !important; text-align:center !important;"> $ L_1 = \{ 1, 2, 3, 4, 5, 6, 7, 8 \} \land L_2 = \{ a, b, c, d, e,
            f, g, h \}$</p>
          <p  class="fragment fade-up">Você consegue explicar porquê?</p>
          <p class="fragment fade-up">No mundo do Xadrez temos $ L_1 = F \wedge L_2 = R$.</p>
        </section>
        <section class="nivel1">
          <h2>Fechamento de Kleene</h2>
          <p  class="fragment fade-up">A operação <i>Kleene Star</i>, ou <i>Fechamento de Kleene</i>, ou só fechamento (<strong>closure</strong>),  
            pode ser definida, de forma intuitiva, como sendo o conjunto formado pela união de todas as formas possíveis de concatenar qualquer número de cópias das
            <strong>strings</strong> da linguagem $L$. Esta operação é representada por um asterisco $*$, de tal forma que:</p>
          <p  class="fragment fade-up" style="text-align:center !important;"> $ L^* = \{ \varepsilon \} \cup L \cup L \cdot L \cup L \cdot L \cdot
            L \cup . . . \}$</p>
          <p  class="fragment fade-up">Na prática fica mais claro!</p>
        </section>
        <section class="nivel1">
          <h2>Fechamento de Kleene - Exemplo</h2>
          <p  class="fragment fade-up">Considerando a linguagem $ L=\{ 0,1 \}$ teremos:</p>
          <ol style="font-size: 80% !important;">
            <li  class="fragment fade-up">$L^0 = \{ \varepsilon \}$</li>
            <li  class="fragment fade-up">$L^1=\{ 0,1 \}$</li>
            <li  class="fragment fade-up">$L^2=L \cdot L^1 = \{ 00,01,10,11 \}$</li>
            <li  class="fragment fade-up">$L^3= \{ 000,001,010,011,100,101,110,111\}$</li>
            <li  class="fragment fade-up">$L^*=\{ \varepsilon,000,001,010,011,100,101,110,111,1000… \}$</li>
          </ol>
          <p class="fragment fade-up">Representando a <strong>União</strong> da <strong>Concatenação</strong> de todos os <strong>strings</strong> possíveis</p>
        </section>
        <section class="nivel1">
           <h2>Identidades das Expressões Regulares</h2>
          <p  class="fragment fade-up">considerando a linguagem $ L_1,L_2 e L_3 $</p>
          <table  class="fragment fade-up" style="width:100%;">
            <tr>
              <td>
                <ol style="font-size: 70% !important;">
                  <li>$\emptyset^*=\varepsilon $</li>
                  <li>$ L_1 \cdot L_1^* = L_1^ * \cdot L_1 $</li>
                  <li>$ L_1^* \cdot L_1^* = L_1^* $</li>
                  <li>$ (L_1^*)^* = L_1^* $</li>
                  <li>$ L_1 \cdot L_1^* = L_1^* \cdot L_1^* $</li>
                </ol>
              </td>
              <td>
                <ol start="6" style="font-size: 70% !important;">
                  <li>$ L_1 + \emptyset = \emptyset + L_1 = L_1 $</li>
                  <li>$ L_1 \cdot \varepsilon = \varepsilon * L_1 = L_1 $</li>
                  <li>$ L_1 \cdot \emptyset = \emptyset * L_1 = \emptyset $</li>
                  <li>$ L_1 + L_1 = L_1 \cup L_1 = L_1 $</li>
                  <li>$ (L_1 + L_2) \cdot L_3 = L_1 \cdot L_3 + L_2 \cdot L_3 $</li>
                </ol>
              </td>
            </tr>
          </table>
          <p  class="fragment fade-up">O uso destas entidades simplifica a análise das expressões regulares de forma algébrica.</p>
        </section>
      </section>
      <section>
        <section class="nivel1">
          <h1>Material de apoio</h1>
          <p  class="fragment fade-up">Você pode baixar o material de apoio <a href="./INTERPRETADORES.pdf">clicando aqui</a> </p>
        </section>
      </section>
    </div>
  </div>
  <div class="home-button"><a href="https://frankalcantara.com"><i class="fas fa-home"></i></a></div>
  <script src="../../rev/reveal.js"></script>
  <script src="../../rev/plugin/notes/notes.js"></script>
  <script src="../../rev/plugin/search/search.js"></script>
  <script src="../../rev/plugin/zoom/zoom.js"></script>
  <script src="../../rev/plugin/math/math.js"></script>
  <script src="../../rev/plugin/menu/menu.js"></script>
  <script src="../../rev/plugin/chalkboard/plugin.js"></script>

  <script>
    Reveal.initialize({
      history: true,
      transition: "default", // none/fade/slide/convex/concave/zoom
      center: false,
      math: {
        mathjax: "https://cdn.jsdelivr.net/gh/mathjax/mathjax@2.7.8/MathJax.js",
        config: "TeX-AMS_HTML-full",
        // pass other options into `MathJax.Hub.Config()`
        TeX: {
          Macros: {
            RR: "{\\bf R}",
          },
        },
      },
      menu: {
        side: "left",
        width: "normal",
        numbers: false,
        titleSelector: "h1, h2, h3, h4, h5, h6",
        useTextContentForMissingTitles: false,
        hideMissingTitles: false,
        markers: true,
        custom: false,
        themes: false,
        themesPath: "dist/theme/",
        transitions: false,
        openButton: true,
        openSlideNumber: false,
        keyboard: true,
        sticky: false,
        autoOpen: true,
        delayInit: false,
        openOnInit: false,
        loadIcons: true,
      },

      // reveal.js plugins
      plugins: [
        RevealNotes,
        RevealMath,
        RevealMenu,
        RevealChalkboard,
        RevealSearch,
        RevealZoom,
      ],
    });
  </script>
</body>

</html>
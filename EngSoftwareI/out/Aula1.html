<!DOCTYPE html>
<html lang="pt">

<head>
  <meta charset="utf-8" />
  <title>Engenharia de Software - Introdução</title>
  <meta name="description" content="Engenharia de Software - Introdução" />
  <meta name="author" content="Frank de Alcantara" />

  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="stylesheet" href="../../rev/reset.css" />
  <link rel="stylesheet" href="../../rev/reveal.css" />
  <link rel="stylesheet" href="../../rev/engsoft1.css" />
  <link rel="stylesheet" href="../../rev/plugin/highlight/monokai.css" id="highlight-theme" />
</head>

<body>
  <div class="reveal default" role="application" data-transition-speed="default" data-background-transition="default">
    <div class="slides">
      <section class="nivel1">
        <section>
          <h1> Engenharia de Software I<br />modelagem</h1>
          <p style="text-align: right !important;"> Frank de Alcantara - 2020 &nbsp;&nbsp;</p>
        </section>
        <section>
          <h3>Ementa</h3>
          <p>
            Processo de desenvolvimento de software. Histórico e
            desenvolvimento do paradigma de <strong>Orientação a Objetos</strong>. Aspectos das
            <strong>linguagens de modelagem de sistemas</strong>.
          </p>
        </section>
        <section>
          <h3>Conteúdo></h3>
          <p><strong>Engenharia de Software</strong>.</p>
          <p>
            <strong>Análise Orientada a Objetos:</strong> história e conceitos
            de aplicação do paradigma de Programação orientada a objetos.
          </p>
          <p>
            <strong>UML2 (Unified Modeling Language):</strong> histórico;
            visão geral dos diagramas da UML; diagrama de casos de uso;
            diagrama de classes; diagrama de sequência...
          </p>
          <p>
            <strong>Tópicos Adicionais em Engenharia de Software.</strong>
          </p>
        </section>
        <section>
          <h3>Ferramentas Sugeridas</h3>
          <p>
            <strong>UML:</strong> <a href="https://www.genmymodel.com/" target="_blank"> Genimodel </a>
          </p>
          <p>
            Mais tarde definiremos as ferramentas para desenvolvimento de software.
          </p>
          <p>
            Estas são apenas <strong>Sugestões</strong>, você pode usar a ferramenta que desejar.
          </p>
        </section>
      </section>
      <section class="nivel1">
        <section>
          <h3>Engenharia</h3>
          <p>
            <q>
              Se um construtor constrói uma casa para alguém, e não a constrói
              de forma correta, e a casa por ele construída cai e mata seu
              proprietário, então o construtor deve ser morto.
            </q>
            (Artigo 229 do código de Hammurabi - 1790 AC)
          </p>
          <p>
            Há quase 4000 anos a humanidade já se preocupava em regular a
            profissão de engenheiro. Deixando claro que a função do engenheiro
            é servir ao usuário de forma adequada e segura.
          </p>
        </section>
        <section>
          <h3>Engenharia de Software</h3>
          <p>
            A <strong>Engenharia de software</strong> é jovem! Podemos marcar
            sua origem na primeira metade do <strong>Século XX</strong>. Ainda
            estamos aprendendo o que é isso!
          </p>
          <p>
            O produto <strong>software é abstrato</strong>, sujeito a mudanças
            constantes, algumas vezes conflitantes. Além disso, o
            desenvolvimento de um produto de software é uma
            <strong>tarefa complexa</strong> com centenas de disciplinas
            diferentes interligadas.
          </p>
        </section>
        <section>
          <h3>Engenharia de Software</h3>
          <p>
            Consiste na <strong>modelagem</strong> de um sistema como forma de
            minimizar a complexidade. Utilizar estes modelos em busca de uma
            <strong>solução viável</strong> para um problema. Avaliando dados,
            descobrindo informações e determinando uma forma de
            <strong>criar e organizar o conhecimento</strong>.
          </p>
          <p>
            Este processo permite criar uma ferramenta
            <strong>racional</strong> para a tomada de decisão, ou execução de
            uma tarefa específica necessária a solução do problema.
          </p>
        </section>
        <section>
          <h3>Sistema</h3>
          <p>
            <strong>Sistemas são conjuntos de partes interagindo para um objetivo
              comum</strong>. Podemos classificá-los em naturais, sociais e artificiais.
          </p>
          <p>
            O objetivo da engenharia é modificar sistemas independente da sua
            natureza. A <strong>Engenharia de Software</strong> lida com
            sistemas artificiais modificando tanto os sistemas naturais quanto
            os sistemas sociais.
          </p>
        </section>
      </section>
      <section class="nivel1">
        <section>
          <h3>Solução de Problemas</h3>
          <p>
          <ol>
            <li>Formular;</li>
            <li>Analisar;</li>
            <li>Buscar soluções;</li>
            <li>Escolher a solução adequada;</li>
            <li>Especificar a solução.</li>
          </ol>
          </p>
          <p>
            A função da engenharia é solucionar problemas. A <strong>Engenharia de Software é uma atividade de
              engenharia</strong>. Requer experiência, experimentação, reuso de soluções e evolução contínua.
          </p>
        </section>
        <section>
          <h3>Engenharia de Software - Processos</h3>
          <p>
          <ol>
            <li>Elicitação de Requerimentos;</li>
            <li>Analise do sistema;</li>
            <li>Design do sistema;</li>
            <li>Design dos objetos;</li>
            <li>Implementação;</li>
            <li>Testes;</li>
            <li>Entrega;</li>
            <li>Manutenção;</li>
          </ol>
          </p>
        </section>
        <section>
          <h3>Engenharia de Software - Processos</h3>
          <p>
            Dependendo dos processos escolhidos para a criação do software, para a gestão do projeto,
            ou mesmo para o modelo de ciclo de vida do produto, estes processos podem ter nomes diferentes,
            podem estar destruídos de forma diferente e podem até não existir.
          </p>
          <p>
            Neste curso, vamos considerar todos indispensáveis. E não vamos nos preocupar com nomes e ordens. Mas,
            vamos focar em <strong>Processos Ágeis</strong>.
          </p>
        </section>
      </section>
      <section class="nivel1">
        <section>
          <h3>Sistemas Modelos</h3>
          <p> <strong>Sistemas são conjuntos de partes interagindo para um objetivo
              comum</strong>. Podemos classificá-los em naturais, sociais e artificiais.
          </p>
          <p>
            <strong>Modelo é uma representação simplificada de um sistema</strong>, ou de parte de um sistema,
            onde estão representadas as funcionalidades essenciais para o entendimento do sistema,
            ou do problema.
          </p>
        </section>
        <section>
          <h3>Modelagem</h3>
          <p>
            <strong>É a arte, e a ciência, de reduzir um problema</strong>
            a sua representação mais simples. Esta é uma técnica de redução de complexidade por
            meio da exclusão das partes do sistema que sejam irrelevantes para a solução do problema em um determinado
            domínio.
          </p>
          <p>
            No caso de um projeto, seu cronograma e seu orçamento são modelos do projeto em si.
          </p>
        </section>
        <section>
          <h3>Modelagem Ágil</h3>
          <p>
            Processos de desenvolvimento ágil como o <i><strong>Scrum</strong></i> e
            <i><strong>eXtreme Programming</strong></i>
            baseiam seu processo de modelagem na criação e análise de <strong><i>User Stories</i></strong>.
            Este é um processo de modelagem dinâmico que mais eficiente se os analistas e
            desenvolvedores conhecerem as técnicas de modelagem clássicas.
          </p>
        </section>
        <section>
          <h3>Modelagem UML</h3>
          <p>
            <strong><i>Unified Modeling Language™</i></strong> ou, Linguagem Unificada de Modelagem é
            O resultado da junção, nos anos 1980 e 1990, de vários esforços para a criação de uma linguagem
            para a modelagem de sistemas desenvolvidos por <a href="https://en.wikipedia.org/wiki/James_Rumbaugh"
              target="_blank">Rumbaugh</a>,
            <a href="https://en.wikipedia.org/wiki/Ivar_Jacobson" target="_blank">Jacobson</a> e
            <a href="https://en.wikipedia.org/wiki/Grady_Booch" target="_blank">Booch</a> e Booch. Em 1996
            a primeira versão da <strong>UML</strong> estava pronta e disponível para uso.
          </p>
          <p>
            Desde então, a <strong>UML</strong> está intimamente relacionada com o <strong><i>Rational Unified
                Process</i> - RUP</strong> da IBM e com o
            paradigma de programação orientada a objetos.
          </p>
        </section>
        <section>
          <h3>Modelagem- Paradigmas de Programação</h3>
          <p>
            Ainda que exista uma relação entre <strong>UML</strong>, <strong>RUP</strong> e programação orientada a
            objetos.
            Não há <strong>nenhuma limitação ao uso da modelagem</strong>, ou mesmo da <strong>UML</strong>, com outros
            paradigmas de programação.
          </p>
          <p>
            Tanto a modelagem em geral, quanto a <strong>UML</strong> em particular, são técnicas para a análise e
            entendimento de problemas.
          </p>
        </section>
        <section>
          <h3>Unified Modeling Language™ - UML</h3>
          <p>
            A <strong>UML</strong> permite criar
          <ul>
            <li>Modelos funcionais (diagrama de caso de uso)</li>
            <li>Modelos de objetos (diagrama de classes)</li>
            <li>Modelos dinâmicos (diagrama de sequência)</li>
          </ul>
          </p>
          <p>
            Alguns autores classificam os diagramas em apenas dois grupos: estáticos e dinâmicos.
          </p>
        </section>
        <section>
          <h3>UML - Diagramas Estáticos</h3>
          <p>
            <strong>Diagramas estáticos</strong>, ou estruturais, descrevem a estrutura do sistema. Usam os objetos,
            seus atributos, operações e relacionamento. Exemplo: diagrama de classes.
          </p>
          <p>
            <strong>Diagramas dinâmicos</strong>, ou comportamentais, descrevem a interação entre os
            componentes do sistema, não raramente, entre objetos. Detalhando as mudanças de
            estado destes objetos. Exemplo: diagrama de casos de uso.
          </p>

        </section>
      </section>
      <section class="nivel1">
        <h3>Fixação Conteúdo</h3>
        <p>Resolva o questionário proposto!!!</p>
      </section>
      <section class="nivel1">
        <section>
          <h3>Um Pouco de História - Simula 67</h3>
          <p>
            Projeto de <a href="https://en.wikipedia.org/wiki/Ole-Johan_Dahl" target="_blank"></a>Ole-Johan Dahl e
            <a href="https://en.wikipedia.org/wiki/Kristen_Nygaard" target="_blank">Kristen Nygaard</a>
            desenvolvido no <a href="https://www.nr.no/en/about-main" target="_blank"></a><strong><i>Norwegian Computing
                Center</i></strong> - (NCC)
            em Oslo entre os anos de 1962 e 1967. Criada para ser uma linguagem capaz de descrever e simular um evento.
            Baseada no ALGOL 60
          </p>
          <p>
            A linguagem continha a maior parte dos conceitos que usamos hoje em linguagens orientadas a objetos.
          </p>

        </section>
        <section>
          <h3>Objetos</h3>
          <p>
            Programação orientada a objetos utiliza <strong>uma abstração da realidade chamada</strong> de objeto que
            abstrai tanto dados quanto procedimentos. Ou seja, um objeto contém dados, que representam seu estado
            e métodos para ler e alterar estes estados.
          </p>
          <p>
            Os objetos são instâncias em memória de artefatos de código chamados de <strong>classes</strong>. São as
            classes que
            definem tanto a abstração de dados quanto os métodos que serão utilizados para sua manipulação.
          </p>

        </section>
        <section>
          <h3>Classes</h3>
          <p>
            A sintaxe utilizada para criar uma classe varia de acordo com os limites de cada uma
            das linguagens de programação orientadas a objetos. <a
              href="https://madnight.github.io/githut/#/pull_requests/2020/2" target="_blank">As linguagens mais
              utilizadas</a>
            são: Javascript, Python, Java, Go, C++, Typescript, Ruby, PHP e C#.
          </p>
          <p>
            Uma classe define um tipo de objeto, assim como a palavra endereço define um tipo de informação.
            Com uma mesma classe, podemos instanciar vários objetos.
          </p>

        </section>
        <section>
          <h3>Instâncias</h3>
          <p>
            A palavra instância se refere a uma classe, em memória, um objeto. O ato de instanciar é o
            ato de criar as estruturas de memória necessárias para suportar um objeto. A classe contém o conjunto
            de instruções que permitirá ao programa criar os objetos que precisa.
          </p>
          <p>
            Uma vez instanciado, um objeto, tem <strong>propriedades</strong> onde estão armazenados seus dados
            e <strong>métodos</strong> que serão utilizados para acessar estes dados.
          </p>

        </section>
        <section>
          <h3>Associação</h3>
          <p>
            Objetos podem ser relacionados por meio de uma <strong>associação</strong>, esta associação
            irá determinar como um objeto de uma determinada classe irá se relacionar com objetos de outras classes.
          </p>
          <p>
            Por exemplo, poderíamos ter uma classe <b class="codigo">Aluno</b> contendo dados sobre alunos que
            fosse associada a classe <b class="codigo">Endereco</b> que conteria dados de endereço.
          </p>

        </section>
        <section>
          <h3>Classes: exemplo</h3>
          <p>
          <pre class="java"><code >public class Aluno
                    {
                      private Vector notas;
                      int nNotas;
                     public void nota(int n);
                      protected boolean notaGravada(int n);
                    }
                </code>
                </pre>
          </p>
        </section>
      </section>
      <section class="nivel1">
        <h3>Fixação de Conteúdo</h3>
        <p>Resolva o questionário proposto!!!</p>
      </section>
      <section class="nivel1">
        <!--Referências e Impressão -->
        <section>
          <h3>Referências</h3>
          <p>BRUEGGE, B.; DUTOIT, A. H. <b>Object-Oriented Software Engineering Using UML, Patterns, and Java</b>.
            3º. ed. Pittsburgh, USA: Prentice Hall, 2010.
          </p>
        </section>
        <section>
          <h3>Impressão</h3>
          <p>Clique <a href="?print-pdf#/">aqui</a> para salvar como pdf.</p>
        </section>
        <section>
          <h3>Agradecimento</h3>
          <img src="https://static.slid.es/reveal/logo-v1/reveal-white-text.svg" alt="reveal.js" style="
               height: 180px;
                margin: 0 auto 4rem auto;
                background: transparent;
              " class="demo-logo" />
          <h3>The HTML Presentation Framework</h3>
          <p>
            <small>Criado por <a href="http://hakim.se">Hakim El Hattab</a> e
              <a href="https://github.com/hakimel/reveal.js/graphs/contributors">colaboradores</a></small>
          </p>
        </section>
      </section>
    </div>
  </div>
  <div class="home-button"><a href="https://frankalcantara.com"><i class="fas fa-home"></i></a></div>
  <script src="../../rev/reveal.js"></script>
  <script src="../../rev/plugin/notes/notes.js"></script>
  <script src="../../rev/plugin/search/search.js"></script>
  <script src="../../rev/plugin/zoom/zoom.js"></script>
  <script src="../../rev/plugin/math/math.js"></script>
  <script src="../../rev/plugin/menu/menu.js"></script>
  <script src="../../rev/plugin/chalkboard/plugin.js"></script>

  <script>
    // Full list of configuration options available at:
    // https://revealjs.com/config/
    Reveal.initialize({
      // Push each slide change to the browser history
      history: true,
      // Transition style
      transition: "fade", // none/fade/slide/convex/concave/zoom
      center:false,
      math: {
        mathjax:
          "https://cdn.jsdelivr.net/gh/mathjax/mathjax@2.7.8/MathJax.js",
        config: "TeX-AMS_HTML-full",
        // pass other options into `MathJax.Hub.Config()`
        TeX: {
          Macros: {
            RR: "{\\bf R}",
          },
        },
      },
      menu: {
        side: "left",
        width: "normal",
        numbers: false,
        titleSelector: "h1, h2, h3, h4, h5, h6",
        useTextContentForMissingTitles: false,
        hideMissingTitles: false,
        markers: true,
        custom: false,
        themes: false,
        themesPath: "dist/theme/",
        transitions: false,
        openButton: true,
        openSlideNumber: false,
        keyboard: true,
        sticky: false,
        autoOpen: true,
        delayInit: false,
        openOnInit: false,
        loadIcons: true,
      },

      // reveal.js plugins
      plugins: [
        RevealNotes,
        RevealMath,
        RevealMenu,
        RevealChalkboard,
        RevealSearch,
        RevealZoom,
      ],
    });
  </script>
</body>

</html>
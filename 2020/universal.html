<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>WebAssembly and the Elusive Universal Binary</title>

<!--
WebAssembly and the Elusive Universal Binary

Many software developers dream of a "universal binary" that would let us build
once and ship everywhere. Of course such a thing would be impossible to do
without some tradeoffs on speed or portability, but it's worth getting as close
as we can! In this talk we'll see how WebAssembly can help here both today and
in the future.
-->

    <meta name="description" content="Wasm and the Elusive Universal Binary">
    <meta name="author" content="Alon Zakai">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black.css" id="theme">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">

    <style type="text/css">
      h2 b {
        color: #f48;
      }
      h3 b {
        color: #f69;
      }
      b {
        color: #af3;
      }
      strong {
        color: #ff3;
      }
    </style>
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h2>WebAssembly and the Elusive Universal Binary</h2>
          <p>
            Alon Zakai (Google)
          </p>
        </section>

        <section>
          <p>
            A "<b>Universal Binary</b>" is a single executable that
            runs on any arch and any OS, and
            runs at 100% of speed.
          </p>
          <hr>
          <p>
            The dream is you build once instead of for each target, and
            despite having a single portable build, it's not noticeably slower.
          </p>
          <hr>
          <p>
            In fact, it doesn't need to actually be a <strong>binary</strong>, so long as it's
            portable and fast.
          </p>
        </section>

        <section>
          <h3><b>Example: My Use Case</b></h3>
          <p>
            Emscripten ships builds of LLVM and Binaryen to users. We build on
            Linux, Mac, and Windows. Most users are happy with those builds.
          </p>
          <hr>
          <p>
            But some users can't use them, for example if they are on BSD or
            a weird Linux.
          </p>
          <hr>
          <p>
            And build infra takes work, sometimes tests only fail there, etc.
          </p>
        </section>

        <section>
          <p>
            Of course a perfect universal binary is a dream. But how close can
            we get?
          </p>
          <hr>
          <p>
            If it's portable and runs at 90% of speed that might be good enough.
          </p>
        </section>

        <section>
          <p>
            In general the closest thing is <b>JavaScript</b>, which can run on any
            Web browser and also on the server, and it works remarkably well
            across those.
          </p>
          <hr>
          <p>
            JS handles execution, and the Web APIs are among the most portable
            out there.
          </p>
          <hr>
          <p>
            Node.js APIs are also quite portable but do go straight
            to the underlying OS for some things (which you often need).
          </p>
        </section>

        <section>
          <p>
            Python on the server is in a similar place: universal execution.
          </p>
          <hr>
          <p>
            JS and Python do not compile to binaries, however, and have some
            overhead and startup time costs.
          </p>
          <hr>
          <p>
            Java and .NET are faster, and compile to a bytecode, but still
            often have startup costs.
          </p>
        </section>

        <section>
          <p>
            Languages like C, C++, Rust, Swift, Go, etc. do compile to binaries and
            have no startup costs. When we think of a "universal binary" I think
            we often think of a way to make those binaries portable.
          </p>
          <hr>
          <p>
            And that's where WebAssembly fits in!
          </p>
        </section>

        <section>
          <h3>WebAssembly: Speed</h3>
          <p>
            Not a literal binary, but designed to start up almost as fast as one,
            by allowing extremely fast "baseline" compilation.
          </p>
          <hr>
          <p>
            After startup, designed to support performance at the level C, C++,
            Rust, etc. expect.
          </p>
        </section>

        <section>
          <h3>WebAssembly: Portability</h3>
          <p>
            Designed for the Web, and execution is just as portable as JavaScript.
          </p>
          <hr>
          <p>
            On the Web it uses Web APIs, again just like JavaScript.
          </p>
          <hr>
          <p>
            Off the Web it can use Node.js APIs or WASI APIs.
          </p>
        </section>

        <section>
          <h3><b>WebAssembly on Node.js</b></h3>
          <p>
            Why Node.js? It's mature, it's everywhere, and it's very easy to
            run wasm and connect it to things - Node.js APIs or libraries.
          </p>
          <hr>
          <p> EXAMPLE
          </p>
        </section>

        <section>
          <h3><b>NODERAWFS</b></h3>
          <p>
            Emscripten's NODERAWFS option connects wasm to Node.js file I/O,
            letting it run like a normal binary.
          </p>
          <hr>
          <pre><code class="js" data-trim>
#include ..
fopen etc.
</code></pre>
        </section>

        <section>
          <h3><b>WASI APIs</b></h3>
          <p>
            Unlike Node.js APIs, these are designed with strict sandboxing. You
            may not need that all the time, but it's incredibly powerful when
            you do.
          </p>
          <hr>
          <p>
            Still fairly new, and will likely never support all of POSIX,
            intentionally - taking the opportunity to redesign what an "OS
            interface is".
          </p>
        </section>

        <section>
          <h3>WASI on Node.js</h3>
          <p>
            Lets you instantiate a wasm binary and give it
            access to the WASI APIs.
          <pre><code class="js" data-trim>
'use strict';
const fs = require('fs');
const { WASI } = require('wasi');
const wasi = new WASI({
  args: process.argv,
  env: process.env,
  preopens: {
    '/sandbox': '/some/real/path/that/wasm/can/access'
  }
});
const importObject = { wasi_snapshot_preview1: wasi.wasiImport };

(async () => {
  const wasm = await WebAssembly.compile(fs.readFileSync('./binary.wasm'));
  const instance = await WebAssembly.instantiate(wasm, importObject);

  wasi.start(instance);
})();
</code></pre>
          </p>
        </section>

        <section>
          <h3><b>WASI on Wasm VMs</b></h3>
          <p>
            wasmtime, wasmer, wavm, etc.
          </p>
          <hr>
          <p>
            These generally have <b>only</b> WASI APIs and nothing else.
          </p>
        </section>

        <section>
          <h3><b>What Works Today?</b></h3>
          <p>
            For example, let's take <b>wasm-opt</b> from Binaryen. It optimizes
            wasm files (usually it shrinks them by X%). Can we run it in wasm?
            (This is my own use case!)
          </p>
        </section>

        <section>
          <p>
            wasm-opt depends on C++ exceptions and/or setjmp. Those are not
            supported in WASI yet, so we can't use that.
          </p>
          <hr>
          <p>
            Emscripten can compile it, and is how binaryen.js is made in fact.
            But instead of making a JS API for it, let's compile the commandline
            tool!
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
emconfigure, emmake, it runs!
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
startup speed. no node.js code caching options atm
          </p>
          <hr>
          <p>
JS as an alternative? "binary" is the same.
          </p>
        </section>

        <section>
          <h3><b>wasm2c</b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <p>
node - no code caching
wasi vm - wasmtime does code caching
wasm2c
http://mozakai.blogspot.com/2013/05/the-elusive-universal-web-bytecode.html
          </p>
        </section>

      </div>


    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/zoom/zoom.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/search/search.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>

      // Also available as an ES module, see:
      // https://revealjs.com/initialization/
      Reveal.initialize({
        controls: true,
        progress: true,
        center: true,
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight ]
      });

    </script>

  </body>
</html>

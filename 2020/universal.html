<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>WebAssembly and the Elusive Universal Binary</title>

<!--
WebAssembly and the Elusive Universal Binary

Many software developers dream of a "universal binary" that would let us build
once and ship everywhere. Of course such a thing would be impossible to do
without some tradeoffs on speed or portability, but it's worth getting as close
as we can! In this talk we'll see how WebAssembly can help here both today and
in the future.
-->

    <meta name="description" content="Wasm and the Elusive Universal Binary">
    <meta name="author" content="Alon Zakai">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black.css" id="theme">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">

    <style type="text/css">
      h2 b {
        color: #f48;
      }
      h3 b {
        color: #f9c;
      }
      b {
        color: #af3;
      }
      strong {
        color: #9af;
      }
    </style>
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h2>WebAssembly and the Elusive Universal Binary</h2>
          <p>
            Alon Zakai (Google)
          </p>
        </section>

        <section>
          <p>
            A "<b>Universal Binary</b>" is a single executable that
            runs on any arch and any OS, and
            runs at 100% of speed.
          </p>
          <hr>
          <p>
            The dream is you build once instead of for each target, and
            despite having a single portable build, it's not noticeably slower.
          </p>
          <hr>
          <p>
            In fact, it doesn't need to actually be a <strong>binary</strong>, so long as it's
            portable and fast.
          </p>
        </section>

        <section>
          <h3><b>Example: My Use Case</b></h3>
          <p>
            Emscripten ships builds of LLVM and Binaryen to users. We build on
            Linux, Mac, and Windows. Most users are happy with those builds.
          </p>
          <hr>
          <p>
            But some users can't use them, for example if they are on BSD or
            a weird Linux.
          </p>
          <hr>
          <p>
            And build infra takes work, sometimes tests only fail there, etc.
          </p>
        </section>

        <section>
          <h3><b>In Other Words</b></h3>
          <p>
            What we want is something like this:
          </p>
          <pre><code class="bash" data-trim>
$ make output # or any other build system
...
$ run output # maybe just ./output, or maybe not
...
</code></pre>
          <p>
            But we want the second part to work on other machines too, and to be fast.
          </p>
        </section>

        <section>
          <h3><b>Can we do that..?</b></h3>
          <p>
            Or rather, how close can we get today?
          </p>
          <p>
            And how close can we get eventually?
          </p>
        </section>

        <section>
          <h3><b>Portability</b></h3>
          <p>
            First, let's distinguish two types of portability.
          </p>
          <hr>
          <p>
            <b>CPU portability</b> concerns <strong>pure computation</strong>, lets you run your code no matter what the
            CPU architecture is.
          </p>
          <hr>
          <p>
            <b>OS portability</b> concerns <strong>APIs</strong>, and lets you do operations like
            printing, file access, etc. no matter the operating system.
          </p>
        </section>

        <section>
          <p>
            <b>The Web</b> has one of the best CPU + OS portability stories. Browser-specific
            bugs definitely exist, and are annoying, but given the scale of the Web
            they are remarkably few!
          </p>
          <hr>
          <p>
            <strong>Node.js, Python, Java, .NET</strong>, and other virtual machines (VMs) provide full
            CPU portability, and some amount of OS portability. Some operations
            are OS-specific; less portable, but more power.
          </p>
        </section>

        <section>
          <pre><code class="bash" data-trim>
$ make output # or any other build system
$ run output # maybe just ./output, or maybe not
</code></pre>
          <hr>
          <p>
            The most practical route to that goal is to <b>compile to a virtual machine</b>
            because those handle CPU portability, and can help with OS portability.
          </p>
        </section>

        <section>
          <p>
            If we have <b>C, C++, Rust, or Go</b>, what VMs can we compile to?
          </p>
          <hr>
          <p>
            All those can compile to <b>WebAssembly</b> (wasm) which solves CPU
            portability. That leaves the API question.
          </p>
        </section>

        <section>
          <p>
            <b>In a console environment</b> there are two main ways to run wasm today:
          </p>
          <hr>
          <p>
            <strong>Node.js</strong>: Very popular VM built on the V8 JavaScript (JS)
            engine. Supports both JS and wasm, and combining
            them is easy.
          </p>
          <hr>
          <p>
            <strong>Wasm VMs</strong>: A new family of VMs built on various wasm
            implementations, including:
            <a href="https://github.com/bytecodealliance/wasmtime">Wasmtime</a>,
            <a href="https://github.com/wasmerio/wasmer">Wasmer</a>,
            <a href="https://github.com/WAVM/WAVM">WAVM</a>,
            <a href="https://github.com/wasm3/wasm3">wasm3</a>, etc.
          </p>
        </section>

        <section>
          <h3><b>WebAssembly APIs</b></h3>
          <hr>
          <p>
            On the Web, wasm uses <strong>Web APIs</strong>, just connect it through JS.
          </p>
          <hr>
          <p>
            Off the Web, the main options are <b>Node.js APIs</b>, <b>WASI APIs</b>,
            and <b>custom embeddings</b>.
          </p>
        </section>

        <section>
          <h3><b>1. Node.js APIs</b></h3>
          <p>
            Node.js APIs are a useful set of OS operations on things like
            <a href="https://nodejs.org/api/fs.html">files</a> and
            <a href="https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options">processes</a> (spawn, fork, etc.).
          </p>
          <hr>
          <pre><code class="js" data-trim>
// No special sandboxing model; like Python etc.,
// this gives the program a reasonably-portable
// set of OS operations.
const fs = require("fs");
fs.readFileSync("data.dat");
</code></pre>
        </section>

        <section>
          <h3><b>2. WASI APIs</b></h3>
          <p>
            The <a href="https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/">WebAssembly System Interface</a>,
            meant for non-Web environments.
          </p>
          <hr>
          <p>
            WASI is <b>not</b> just a bunch of familiar APIs brought to wasm! It is a
            new approach to writing an OS interface layer, a replacement for
            something like POSIX.
          </p>
          <hr>
          <p>
            In particular WASI uses <a href="https://en.wikipedia.org/wiki/Capability-based_security">capability-based security</a>.
          </p>
        </section>

        <section>
          <h3><b>3. Custom embedding APIs</b></h3>
          <hr>
          <p>
            A game engine with wasm plugins may provide APIs to the engine's
            internals, for example.
          </p>
        </section>

        <section>
          <h3><b>The future</b></h3>
          <p>
            Custom APIs will always exist, but otherwise in the long term
            WASI will likely be the best option, at least when it supports
            what you want.
          </p>
          <hr>
          <p>
            WASI is still fairly new, and designing a new OS API takes time. In
            the long term it will likely be the best option!
          </p>
          <hr>
          <p>
            Node.js is also adding WASI support.
          </p>
        </section>

        <section>
          <h3><b>What can we do today?</b></h3>
          <p>
            WASI lacks support for various things:
            <ul>
              <li>setjmp/longjmp</li>
              <li>C++ exceptions</li>
              <li>threads</li>
              <li>process management (how will it be sandboxed?)</li>
              <li>etc.</li>
            </ul>
          </p>
          <hr>
          <p>
            But with JS + Node.js APIs it is possible
            for a wasm program to do those things.
          </p>
        </section>

        <section>
          <h3><b>NODERAWFS</b></h3>
          <p>
            Emscripten's NODERAWFS option connects wasm to Node.js file I/O,
            letting it run like a normal binary.
          </p>
          <hr>
          <pre><code class="js" data-trim>
#include ..
fopen etc.
</code></pre>
        </section>

        <section>
          <h3><b>WASI APIs</b></h3>
          <p>
            Unlike Node.js APIs, these are designed with strict sandboxing. You
            may not need that all the time, but it's incredibly powerful when
            you do.
          </p>
          <hr>
          <p>
            Still fairly new, and will likely never support all of POSIX,
            intentionally - taking the opportunity to redesign what an "OS
            interface is".
          </p>
        </section>

        <section>
          <h3>WASI on Node.js</h3>
          <p>
            Lets you instantiate a wasm binary and give it
            access to the WASI APIs.
          <pre><code class="js" data-trim>
'use strict';
const fs = require('fs');
const { WASI } = require('wasi');
const wasi = new WASI({
  args: process.argv,
  env: process.env,
  preopens: {
    '/sandbox': '/some/real/path/that/wasm/can/access'
  }
});
const importObject = { wasi_snapshot_preview1: wasi.wasiImport };

(async () => {
  const wasm = await WebAssembly.compile(fs.readFileSync('./binary.wasm'));
  const instance = await WebAssembly.instantiate(wasm, importObject);

  wasi.start(instance);
})();
</code></pre>
          </p>
        </section>

        <section>
          <h3><b>WASI on Wasm VMs</b></h3>
          <p>
            wasmtime, wasmer, wavm, etc.
          </p>
          <hr>
          <p>
            These generally have <b>only</b> WASI APIs and nothing else.
          </p>
        </section>

        <section>
          <h3><b>What Works Today?</b></h3>
          <p>
            For example, let's take <b>wasm-opt</b> from Binaryen. It optimizes
            wasm files (usually it shrinks them by X%). Can we run it in wasm?
            (This is my own use case!)
          </p>
        </section>

        <section>
          <p>
            wasm-opt depends on C++ exceptions and/or setjmp. Those are not
            supported in WASI yet, so we can't use that.
          </p>
          <hr>
          <p>
            Emscripten can compile it, and is how binaryen.js is made in fact.
            But instead of making a JS API for it, let's compile the commandline
            tool!
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
emconfigure, emmake, it runs!
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
startup speed. no node.js code caching options atm
          </p>
          <hr>
          <p>
JS as an alternative? "binary" is the same.
          </p>
        </section>

        <section>
          <h3><b>wasm2c</b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <h3><b></b></h3>
          <p>
          </p>
          <hr>
          <p>
          </p>
        </section>

        <section>
          <p>
node - no code caching
wasi vm - wasmtime does code caching
wasm2c
http://mozakai.blogspot.com/2013/05/the-elusive-universal-web-bytecode.html
          </p>
        </section>

      </div>


    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/zoom/zoom.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/search/search.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>

      // Also available as an ES module, see:
      // https://revealjs.com/initialization/
      Reveal.initialize({
        controls: true,
        progress: true,
        center: true,
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight ]
      });

    </script>

  </body>
</html>

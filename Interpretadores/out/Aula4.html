<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="author" content="Frank Coelho de Alcantara">
    <title>Gramáticas - Analisador Léxico</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
    <link rel="stylesheet" href="../../rev/reset.css">
    <link rel="stylesheet" href="../../rev/reveal.css">
    <link rel="stylesheet" href="../../rev/aulas.css" />
    <link rel="stylesheet" href="../../rev/interpret.css" />
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section id="title-slide">
          <h1 class="title">Gramáticas <br /> Analisadores Léxicos</h1>
          <p class="author" style="text-align: right !important;">Frank Coelho de Alcantara</p>
        </section>
        <section>
          <section class="title-slide slide level1">
            <h2>Gramáticas</h2>
            <p>
              A linguagem das linguagens: Uma gramática é uma lista de regras que determina como podem ser criadas e
              utilizadas todas as strings de uma linguagem;
            </p>
          </section>
          <section>
            <h2>Classificação de Chomsky</h2>
            <ul>
              <li>Gramáticas Irrestritas;</li>
              <li>Gramáticas Sensíveis ao Contexto;</li>
              <li>Gramáticas Livres de Contexto;</li>
              <li>Gramáticas Regulares.</li>
            </ul>
          </section>
          <section>
            <h2>Linguagens</h2>
            <table style="font-size: 80% !important;">
              <tbody>
                <tr>
                  <th><i>Linguagem</i></th>
                  <th><i>Gramática</i></th>
                  <th><i>Identificador</i></th>
                </tr>
                <tr>
                  <td>Recursivamente Enumerárveis</td>
                  <td>Gramáticas Irrestritas</td>
                  <td>Máquina de Touring</td>
                </tr>
                <tr>
                  <td>Lingugagens sensíveis ao contexto</td>
                  <td>Gramáticas sensíveis ao contexto</td>
                  <td>Maq. Turing com fita limitada</td>
                </tr>
                <tr>
                  <td>Linguagens livres de contexto</td>
                  <td>Gramáticas livres de contexto</td>
                  <td>Autômato com pilha</td>
                </tr>
                <tr>
                  <td>Linguagens Regulares</td>
                  <td>Gramáticas regulares</td>
                  <td>Autômato finito</td>
                </tr>
              </tbody>
            </table>
          </section>
          <section>
            <h2>Gramáticas - definição</h2>
            <p>Uma Gramática Formal: 4-tupla: – $𝑮 := \{𝑵, \Sigma, 𝑷, 𝑺\}$</p>
            <ul>
              <li>$S\rightarrow \text{símbolo inicial}$</li>
              <li>$\Sigma \rightarrow \text{símbolos terminais}$</li>
              <li>$P \rightarrow \text{regras de produção}$</li>
              <li>$N \rightarrow \text{símbolos não terminais}$</li>
            </ul>
          </section>
          <section>
            <h2>Símbolos terminais</h2>
            <p>
              Símbolos termais tem esse nome por que não existem regras para substitui-los. Uma vez gerados, os símbolos
              terminais são permanentes. Consequentemente, os símbolos termais são os símbolos da linguagem.
            </p>
          </section>
          <section>
            <h2>Livres de Contexto</h2>
            <p>
              “uma gramática livre de contexto descreve um conjunto de strings, ou linguagem, por meio da definição da
              estrutura das strings da linguagem. Esta definição é recursiva, indicando que cada regra produção pode, ou
              não, ser utilizada para definir novas regras de produção”
            </p>
          </section>
        </section>
        <section>
          <section>
            <h2>Regras de Produção</h2>
            <p>
              Os símbolos que aparecem à esquerda da seta, são não terminais e representados por letras latinas maiúsculas
              $(𝐴, 𝐵, 𝑆, …)$.
            </p>
            <p>O símbolo inicial é o que aparece do lado esquerdo da primeira regra $𝑆$.</p>
            <p>Pode ser qualquer símbolo, usarmos o $𝑆$ por convenção.</p>
          </section>
          <section>
            <h2>Regras de Produção</h2>
            <ol>
              <li>$𝑆 \rightarrow 𝐴𝐵$</li>
              <li>$𝑆 \rightarrow 𝐴𝑆𝐵$</li>
              <li>$𝐴 \rightarrow a$</li>
              <li>$𝐵 \rightarrow b$</li>
            </ol>
            <p>Vamos produzir a string:“aabb”</p>
          </section>
          <section>
            <h2>Produzindo $aabb$</h2>
            <p class="fragment fade-up">Temos $S \rightarrow \emptyset$ e aplicamos 2 $𝑺 \rightarrow
              𝑨𝑺𝑩$</p>
            <p class="fragment fade-up">Temos de $S \rightarrow ASB$ e aplicamos 3 $𝑺 \rightarrow a$</p>
            <p class="fragment fade-up">Temos de $S \rightarrow aSB$ e aplicamos 4 $𝑺 \rightarrow b$</p>
            <p class="fragment fade-up">Temos de $S \rightarrow aSb$ e aplicamos 1 $𝑺 \rightarrow AB$</p>
            <p class="fragment fade-up">Temos de $S \rightarrow aABb$ e aplicamos 3 $𝑺 \rightarrow a$</p>
            <p class="fragment fade-up">Temos de $S \rightarrow aaBb$ e aplicamos 4 $𝑺 \rightarrow b$</p>
            <p class="fragment fade-up">Conseguimos: $S \rightarrow aabb$</p>
          </section>
          <section>
            <h2>Exercício 1</h2>
            <p>Considere a gramática definida por: </p>
            <ol>
              <li>$𝑺 \rightarrow 𝑨𝑩$</li>
              <li>$𝑨 \rightarrow \varepsilon | 𝒂𝑨$</li>
              <li>$𝑩 \rightarrow \varepsilon | 𝒃𝑩$</li>
            </ol>
            <p>Encontre uma sequência de substituições para encontrar: $aab$</p>
          </section>
          <section>
            <h2>Gramáticas Regulares</h2>
            <p>Duas classes de regras de produção.</p>
            <p>Lineares à Direita: as regras de produção obedecem:
              $$𝑨 \rightarrow 𝒘𝑩 \vee 𝑨\rightarrow 𝒘 (𝒘 \in \Sigma^*)$$ </p>
            <p>Lineares à esquerda: as regras de produção obedecem:
              $$𝑨 \rightarrow 𝑩𝒘 \vee 𝑨 \rightarrow 𝒘 (𝒘 \in \Sigma^*)$$</p>
          </section>
        </section>
        <section>
          <section>
            <h2>Ávores Sintáticas</h2>
            <ol class="fragment fade-up" style="float: left; margin-left: 10%;">
              <li>$S$</li>
              <li>$S \rightarrow ASB$</li>
              <li>$S \rightarrow aSB$</li>
              <li>$S \rightarrow aSb$</li>
              <li>$S \rightarrow aABb$</li>
              <li>$S \rightarrow aaBb$</li>
              <li>$S \rightarrow aabb$</li>
            </ol>
            <p class="fragment fade"><img data-src="../img/as1.png" alt="exemplo de máquina de estados finitos"
                style="float:righ; margin-left: 20%; max-width: 40%;;" /> </p>
          </section>
          <section>
            <h2>Backus-Naur Form - BNF</h2>
            <p>Representa uma gramática.</p>
            <p>É mais simples para leitura.</p>
            <p>É mais simples para escrita.</p>
            <p>ISO/IEC 14977 : 1996(E).</p>
          </section>
          <section>
            <h2>Backus-Naur Form - BNF</h2>
            <p>$::= \rightarrow $ “é definido como” ou “pode ser substituído por”</p>
            <p>$| \rightarrow $ seleção: ou.</p>
            <p>$<> \rightarrow $ não terminais.</p>
            <p>Você faz a linguagem, você faz as regras!</p>
          </section>
          <section>
            <h2>BNF - Exemplo</h2>
            <ol class="fragment fade-up" style="float: left; margin-left: 10%;">
              <li>$\text{<𝑙𝑖𝑠𝑡𝑎> ∷= <𝑒𝑙𝑒𝑚𝑒𝑛𝑡𝑜>;<𝑙𝑖𝑠𝑡𝑎> | <𝑒𝑙𝑒𝑚𝑒𝑛𝑡𝑜>}$</li>
              <li>$\text{<𝑒𝑙𝑒𝑚𝑒𝑛𝑡𝑜>∷=<𝑙𝑒𝑡𝑟𝑎>
                    <𝑑𝑖𝑔𝑖𝑡𝑜>}$</li>
              <li>$\text{<𝑙𝑒𝑡𝑟𝑎>∷=𝐴 | 𝐵 |𝐶}$</li>
              <li>$\text{<𝑑𝑖𝑔𝑖𝑡𝑜>∷=1|2|3|4}$</li>
            </ol>
          </section>
          <section>
            <h2>EBNF</h2>
            <ul>
              <li>Removeu os $<$$>$ para os símbolos não terminais.</li>
              <li>Símbolos termais expressos entre aspas.</li>
              <li>Uso $*$ para fechamento e $\{\}$ para multiplicação.</li>
              <li>Uso de $+$ para um ou mais.</li>
              <li>Uso de $?$ para seleção.</li>
              <li>Parênteses $()$ para agrupamento;</li>
              <li>Substitui $∷=$ por $=$.</li>
              <li>O uso da vírgula $,$ para explicitar concatenação.</li>
              <li>O ponto encerra uma regra.</li>
            </ul>
          </section>
          <section>
            <h2>BNF - Exemplo</h2>
            <p>Considere a seguinte gramática definida em BNF</p>
            <ol style="font-size: 70%;">
              <li>$<𝒑𝒓𝒐𝒈𝒓𝒂𝒎> ::= 𝒃𝒆𝒈𝒊𝒏 <𝒔𝒕𝒎𝒕\_𝒍𝒊𝒔𝒕> 𝒆𝒏𝒅$</li>
              <li>$<𝒔𝒕𝒎𝒕_𝒍𝒊𝒔𝒕> ::= <𝒔𝒕𝒎𝒕> | <𝒔𝒕𝒎𝒕> ; <𝒔𝒕𝒎𝒕_𝒍𝒊𝒔𝒕>$.</li>
              <li>$<𝒔𝒕𝒎𝒕> ::= <𝒗𝒂𝒓> = <𝒆𝒙𝒑𝒓>$</li>
              <li>$<𝒆𝒙𝒑𝒓> ::= <𝒕𝒆𝒓𝒎> + <𝒕𝒆𝒓𝒎> | <𝒕𝒆𝒓𝒎> − <𝒕𝒆𝒓𝒎>$</li>
              <li>$<𝒕𝒆𝒓𝒎> ::= <𝒗𝒂𝒓> | 𝒄𝒐𝒏𝒔𝒕$</li>
              <li>$<𝒗𝒂𝒓> ::= 𝒂 | 𝒃 | 𝒄$</li>
            </ol>
            <p>Derive o seguinte programa:</p>
            <p>$\text{begin } a = b + \text{ const } \text{ end}$</p>
          </section>
          <section>
            <h2>BNF - Exemplo</h2>
            <ul style="font-size: 70%;">
              <li>$ &lt;program&gt; \Rightarrow \emptyset$ </li>
              <li>Regra 1: $ &lt;program&gt; \Rightarrow begin &lt;stmt\_list&gt; \text{ end}$ </li>
              <li>Regra 2: $&lt;program&gt; \Rightarrow \text{begin } &lt;stmt&gt; \text{ end}$ </li>
              <li>Regra 3: $&lt;program&gt; \Rightarrow \text{begin } &lt;var&gt; = &lt;expr&gt; \text{ end}$ </li>
              <li>Regra 6: $&lt;program&gt; \Rightarrow \text{begin } a = &lt;expr&gt; \text{ end}$ </li>
              <li>Regra 4: $&lt;program&gt; \Rightarrow \text{begin } a = &lt;term&gt; + &lt;term&gt; \text{ end}$ </li>
              <li>Regra 5: $&lt;program&gt; \Rightarrow \text{begin } a = &lt;var&gt; + &ltterm&gt; \text{ end}$ </li>
              <li>Regra 6: $&lt;program&gt; \Rightarrow \text{begin } a = b + &lt;term&gt; \text{ end}$ </li>
              <li>Regra 5: $&lt;program&gt; \Rightarrow \text{begin } a = b + const \text{ end}$ </li>
            </ul>
          </section>
        </section>
        <section>
          <section>
            <h2>Parsers</h2>
            <p>Percorrer, varrer. Técnicas de percorrer uma árvore sintática validando a gramática.</p>
          </section>
          <section>
            <h2>Parsers</h2>
            <p><img data-src="../img/parsers.png" alt="algoritmos de parser mais comuns" />
            </p>
          </section>
          <section>
            <h2>Exemplo</h2>
            <p>Considerando a gramática a seguir, apresente as derivações necessárias para encontrar “abbcde”, usando
              <strong>Bottom-up</strong> parser.</p>
            <ol class="fragment fade-up" style="float: left; font-size:60%; margin-left: 10%;">
              <li>$S \rightarrow aABe$</li>
              <li>$A \rightarrow Abc | b $</li>
              <li>$B \rightarrow d$</li>
            </ol>
            <p class="fragment fade" style="float:righ; font-size: 60%; margin-left: 40%; max-width: 40%;">Regra 2:
              $abbcde \Rightarrow
              aAbcde$
            </p>
            <p class="fragment fade" style="float:righ; font-size: 60%; margin-left: 40%; max-width: 40%;">Regra 2:
              $abbcde \Rightarrow aAde;$
            </p>
            <p class="fragment fade" style="float:righ; font-size: 60%; margin-left: 40%; max-width: 40%;">Regra 3:
              $abbcde \Rightarrow aABe;$
            </p>
            <p class="fragment fade" style="float:righ; font-size: 60%; margin-left: 40%; max-width: 40%;">Regra 1:
              $abbcde \Rightarrow S;$
            </p>
          </section>
          <section>
            <h2>Código</h2>
            <p>Vamos criar um parser para validar fórmulas de cálculo proposicional.</p>
            <ol>
              <li>Negação: $\neg P$</li>
              <li>Conjunção: $P\land Q$</li>
              <li>Disjunção: $P\lor Q$</li>
              <li>Implicação: $P\rightarrow Q$</li>
              <li>Implicação Dupla: $P\leftrightarrow Q$</li>
            </ol>
            <p>Nosso parser deve ser recursivo e usar latex e notação rpn para a digitação das expressões.</p>
          </section>
          <section>
            <h2>EBNF - Exercício </h2>
            <p>Vamos criar um parser para validar fórmulas de cálculo proposicional.</p>
            <ol>
              <li>$Formula = Constante | Proposicao | FormulaUnaria | FormulaBinaria.$</li>
              <li>$Constante = "T" | "F".$</li>
              <li>$Proposicao = [a-z0-9]+$</li>
              <li>$FormulaUnaria = AbreParen OperadorUnario Formula FechaParen$</li>
              <li>$FormulaBinaria= AbreParen OperatorBinario Formula Formula FechaParen$</li>
              <li>$AbreParen = "("$</li>
              <li>$FechaParen = ")"$</li>
              <li>$OperatorUnario = "\neg"$</li>
              <li>$OperatorBinario = "\vee" | "\wedge" | "\rightarrow" | "\leftrightarrow"$</li>
            </ol>
          </section>
        </section>

        <section>
          <section>
            <h1>Material de apoio</h1>
            <p>Você pode baixar o material de apoio <a href="./INTERPRETADORES.pdf">clicando aqui</a> </p>
          </section>
          <section>
            <h2>Obras Citadas</h2>
            <p>
              AHO, A. V. et al. <strong>Compiladores: princípios, técnicas e ferramentas</strong>. 2º. ed. Boston, MA,
              USA: Pearson
              Education Inc. , 2007. <br />
              CASS, S. <strong>The 2016 Top Programming Languages</strong>. IEEE Spectrum, 2016. Disponível em:
              <http://spectrum.ieee.org/computing/software/the-2016-top-programming-languages>. Acesso em: 22 Set. 2016. </p> </section> </section> </div>
                </div> <script src="../../rev/reveal.js">
                </script>
                <script src="../../rev/plugin/notes/notes.js"></script>
                <script src="../../rev/plugin/search/search.js"></script>
                <script src="../../rev/plugin/zoom/zoom.js"></script>
                <script src="../../rev/plugin/math/math.js"></script>
                <script src="../../rev/plugin/menu/menu.js"></script>
                <script src="../../rev/plugin/chalkboard/plugin.js"></script>

                <script>
                  // Full list of configuration options available at:
                  // https://revealjs.com/config/
                  Reveal.initialize({
                    // Push each slide change to the browser history
                    history: true,
                    // Transition style
                    transition: 'fade', // none/fade/slide/convex/concave/zoom

                    math: {
                      mathjax: 'https://cdn.jsdelivr.net/gh/mathjax/mathjax@2.7.8/MathJax.js',
                      config: 'TeX-AMS_HTML-full',
                      // pass other options into `MathJax.Hub.Config()`
                      TeX: {
                        Macros: {
                          RR: "{\\bf R}"
                        }
                      }
                    },
                    menu: {
                      side: 'left',
                      width: 'normal',
                      numbers: false,
                      titleSelector: 'h1, h2, h3, h4, h5, h6',
                      useTextContentForMissingTitles: false,
                      hideMissingTitles: false,
                      markers: true,
                      custom: false,
                      themes: false,
                      themesPath: 'dist/theme/',
                      transitions: false,
                      openButton: true,
                      openSlideNumber: false,
                      keyboard: true,
                      sticky: false,
                      autoOpen: true,
                      delayInit: false,
                      openOnInit: false,
                      loadIcons: true
                    },

                    // reveal.js plugins
                    plugins: [
                      RevealNotes,
                      RevealMath,
                      RevealMenu,
                      RevealChalkboard,
                      RevealSearch,
                      RevealZoom
                    ]
                  });
                </script>
  </body>

</html>